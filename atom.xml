<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yuchen&#39;s Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-03-21T13:43:44.666Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Yuchen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DFt</title>
    <link href="http://example.com/2022/03/21/DFt/"/>
    <id>http://example.com/2022/03/21/DFt/</id>
    <published>2022-03-21T09:01:01.000Z</published>
    <updated>2022-03-21T13:43:44.666Z</updated>
    
    <content type="html"><![CDATA[<p>这是DFT Compiler的学习笔记</p><h1><span id="lab1">Lab1</span></h1><p>第一个lab用来理解dft设计过程中的总体概念</p><p>unmapped flow（指直接由RTL语言组成的设计，没有映射为网表。）</p><p>1、将RTL设计读入DFTC中</p><p>2、创建测试协议，并确定设计和protocol的兼容性</p><p>3、编译并保存门级网表</p><p>mapped flow（综合后的网表）</p><p>1、将设计和protocol读入DFTC</p><p>2、例化扫描约束和预览扫描结构</p><p>3、插入扫描链</p><p><img src="D:%5COneDrive%5COneDrive%20-%20stu.xmu.edu.cn%5C%E6%A1%8C%E9%9D%A2%5C%E5%9B%BE%E5%BA%8A%5C%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220321194740.png" alt="微信截图_20220321194740"></p><p>共有七个脚本</p><p>1、read design</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> hdlin_enable_rtldrc_info true<span class="comment">;# enable rtl code checking in DV</span></span><br><span class="line"></span><br><span class="line">acs_read_hdl -f vhdl -hdl_source &#123;../ref/rtl/RISC_CORE/vhdl&#125; RISC_CORE#以VHDL模式读取hdl源码 </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、create test protocol</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># find out if there are any multiple instantiations of a block</span></span><br><span class="line">check_design -summary</span><br><span class="line"></span><br><span class="line"><span class="keyword">source</span> scripts/settings_protocol.tcl#执行settings_protocol这个脚本</span><br><span class="line"><span class="comment">#From the above specifications, create the test protocal</span></span><br><span class="line">create_test_protocol</span><br><span class="line"></span><br><span class="line"><span class="comment">#check the test_protocol</span></span><br><span class="line">dft_drc</span><br><span class="line"></span><br><span class="line"><span class="comment">#write out the test protocol to use again in the mapped flow</span></span><br><span class="line">write_test_protocol -out unmapped/unmapped_flow.spf</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>settings_protocol.tcl如下</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#step2 -- read</span></span><br><span class="line"><span class="comment">#specify test components in preparation for create_test_protocol</span></span><br><span class="line"></span><br><span class="line">set_dft_signal -view existing_dft -type ScanClock -timing &#123;<span class="number">45</span> <span class="number">55</span>&#125; -port Clk</span><br><span class="line">set_dft_signal -view existing_dft -port Reset -type Reset -active_state <span class="number">0</span></span><br><span class="line">set_dft_signal -view spec -port TEST_SE -type ScanEnable -active_state <span class="number">1</span></span><br><span class="line">set_dft_signal -view existing_dft -type Constant -active_state <span class="number">1</span> -port TEST_MODE</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置了扫描始终、重置信号、扫描使能信号、测试模式信号</span></span><br><span class="line"><span class="comment">#step three -- nothing</span></span><br></pre></td></tr></table></figure><p>existing_dft，用于定义插链前已经连接好的信号。比如时钟复位，跟一些constant的控制信号一般在插链前已经连接好了，只需要告诉工具这是一个什么信号，控制为什么值就行了。<br>spec：用于定义未链接好的信号，再插链时需要工具连接。比如scan_enabl,si,so。<br>另外，如果进行插链的电路里面已经有插好的链，那么其scan_enable也定义为existing_dft。比如，有一部分IP已经插好链了SE连到了端口dft_se，还有一部分寄存器在这次插链的时候希望把SE也连接到dft_se上去，这样就可以把dft_se在existing_dft和spec里面都定义一下。</p><p>3、compile and save</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">source</span> -echo -verbose scripts/constraints.tcl<span class="comment">;# apply non test constraints to the design</span></span><br><span class="line"><span class="comment">#-echo -verbose这个是用来显示命令和命令结果</span></span><br><span class="line">compile -<span class="keyword">scan</span></span><br><span class="line">write -<span class="keyword">format</span> ddc -hierarchy -output mapped/RISC_CORE.ddc</span><br><span class="line"><span class="comment">#输出一个映射好的ddc文件</span></span><br></pre></td></tr></table></figure><p>constraints.tcl如下</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create user defined variables</span></span><br><span class="line"><span class="keyword">set</span> CLK_PORT [get_ports Clk]#get_ports由Clk处取得时钟接口</span><br><span class="line"><span class="keyword">set</span> CLK_PERIOD <span class="number">10.0</span> </span><br><span class="line"><span class="keyword">set</span> WC_SKEW <span class="number">0.25</span> #<span class="keyword">clock</span> skew时钟偏移，这里的WC_SKEW不知道是哪个偏移</span><br><span class="line"><span class="keyword">set</span> DRV_CELL bufbd1</span><br><span class="line"><span class="keyword">set</span> DRV_PIN <span class="string">&quot;Z&quot;</span></span><br><span class="line"><span class="keyword">set</span> OUTPUT_LOAD [load_of cb13fs120_tsmc_max/bufbd1/I]</span><br><span class="line"><span class="keyword">set</span> INPUT_DELAY <span class="number">1.0</span></span><br><span class="line"><span class="keyword">set</span> OUTPUT_DELAY <span class="number">1.0</span></span><br><span class="line"><span class="keyword">set</span> ALL_INS_EX_CLK  [remove_from_collection [all_inputs] [get_ports Clk]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create_clock -period <span class="variable">$CLK_PERIOD</span> -name my_clk <span class="variable">$CLK_PORT</span></span><br><span class="line"></span><br><span class="line">set_clock_uncertainty <span class="variable">$WC_SKEW</span> [get_clocks my_clk]</span><br><span class="line"></span><br><span class="line">set_driving_cell -lib_cell <span class="variable">$DRV_CELL</span> -pin <span class="variable">$DRV_PIN</span> <span class="variable">$ALL_INS_EX_CLK</span>#设置驱动的器件，其中cell可以是一个具体的器件，也可以是一个module</span><br><span class="line"></span><br><span class="line">set_load <span class="variable">$OUTPUT_LOAD</span> [all_outputs]</span><br><span class="line"></span><br><span class="line">set_input_delay <span class="variable">$INPUT_DELAY</span> -max -<span class="keyword">clock</span> my_clk <span class="variable">$ALL_INS_EX_CLK</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="variable">$OUTPUT_DELAY</span> -max -<span class="keyword">clock</span> my_clk [all_outputs]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4、read gate and protocol</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">remove_design -designs <span class="comment">; # Remove the in-memory results of step 3 去除之前的未映射的缓存结果</span></span><br><span class="line"></span><br><span class="line">read_ddc mapped/RISC_CORE.ddc <span class="comment">;# note this was created during the unmapped flow</span></span><br><span class="line"><span class="keyword">set</span> current_design RISC_CORE</span><br><span class="line">link</span><br><span class="line">read_test_protocol unmapped/unmapped_flow.spf</span><br><span class="line">dft_drc</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5、preview_dft</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">source</span> scripts/settings_insert_dft.tcl</span><br><span class="line"></span><br><span class="line">preview_dft<span class="comment">; # lets you know what you will get -- iterate from here - </span></span><br></pre></td></tr></table></figure><p>6、insert dft</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insert_dft</span><br><span class="line"></span><br><span class="line">dft_drc -coverage_estimate</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>7、hand off</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">change_names -rules verilog -hierarchy</span><br><span class="line">report_scan_configuration &gt; reports/scan_config</span><br><span class="line">report_dft_signal -view spec &gt; reports/dft_signals</span><br><span class="line">report_dft_signal -view existing_dft &gt;&gt; reports/dft_signals</span><br><span class="line">report_scan_path -view existing_dft -chain all &gt; reports/scan_chains</span><br><span class="line">report_scan_path -view existing_dft -cell all &gt; reports/scan_cells</span><br><span class="line"><span class="keyword">set</span> test_stil_netlist_format verilog <span class="comment">;# hand off</span></span><br><span class="line">write -f verilog -h -o tmax/RISC_CORE_SCAN.v</span><br><span class="line">write_test_protocol -o tmax/RISC_CORE_SCAN.spf</span><br><span class="line">write -<span class="keyword">format</span> ddc -hierarchy -output mapped_scan/RISC_CORE.ddc</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一些课后题</p><ol><li>dft_drc的作用：检查设计与protocol的兼容性，检查扫描连是否符合设计规则</li></ol><p>__本文作者__：Yuchen <a href="http://example.com/2022/03/21/DFt/">http://example.com/2022/03/21/DFt/</a> <br>__版权声明__：转载请注明出处！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是DFT Compiler的学习笔记&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;lab1&quot;&gt;Lab1&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;第一个lab用来理解dft设计过程中的总体概念&lt;/p&gt;
&lt;p&gt;unmapped flow（指直接由RTL语言组成的设计，没有映射为网表。）&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="DFT" scheme="http://example.com/tags/DFT/"/>
    
  </entry>
  
  <entry>
    <title>testbentch_lab</title>
    <link href="http://example.com/2022/02/05/testbentch-lab/"/>
    <id>http://example.com/2022/02/05/testbentch-lab/</id>
    <published>2022-02-05T13:31:05.000Z</published>
    <updated>2022-03-21T13:44:23.543Z</updated>
    
    <content type="html"><![CDATA[<p>重新用questasim跑了一下普通版的tb，理一下思路</p><p>包括下面这些文件</p><h2><span id="文件列表">文件列表</span></h2><p>│  Packet.sv</p><p>│  Driver.sv│  DriverBase.sv</p><p>│  Receiver.sv│  ReceiverBase.sv</p><p>│  Generator.sv</p><p>│  Scoreboard.sv</p><p>│  router.v│  router_io.sv│  router_test_top.sv</p><p>│  test.sv</p><h2><span id="packet">Packet</span></h2><p>packet是最底层的一个类，它定义了所有传输的数据包类型，在后面的所有文件中均调用该类</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span>[<span class="number">3</span>:<span class="number">0</span>] sa, da;<span class="comment">// random port selection</span></span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] payload[$];<span class="comment">// random data array</span></span><br><span class="line">       <span class="keyword">string</span>   name;<span class="comment">// unique identifier</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constraint</span> Limit &#123;</span><br><span class="line">    sa <span class="keyword">inside</span> &#123;[<span class="number">0</span>:<span class="number">15</span>]&#125;;</span><br><span class="line">    da <span class="keyword">inside</span> &#123;[<span class="number">0</span>:<span class="number">15</span>]&#125;;</span><br><span class="line">    payload<span class="variable">.size</span>() <span class="keyword">inside</span> &#123;[<span class="number">2</span>:<span class="number">4</span>]&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;Packet&quot;</span>);</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">function</span> <span class="keyword">bit</span> compare(Packet pkt2cmp, <span class="keyword">ref</span> <span class="keyword">string</span> message);</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">function</span> <span class="keyword">void</span> display(<span class="keyword">string</span> prefix = <span class="string">&quot;NOTE&quot;</span>);</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure><p>可以看到随机化了输入端口、输出端口、以及数据队列。</p><p>包含三个函数，新建、比较以及显示。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">bit</span> Packet::compare(Packet pkt2cmp, <span class="keyword">ref</span> <span class="keyword">string</span> message);</span><br><span class="line">  <span class="keyword">if</span> (payload<span class="variable">.size</span>() != pkt2cmp<span class="variable">.payload</span><span class="variable">.size</span>()) <span class="keyword">begin</span></span><br><span class="line">    message = <span class="string">&quot;Payload Size Mismatch:\n&quot;</span>;</span><br><span class="line">    message = &#123; message, <span class="built_in">$psprintf</span>(<span class="string">&quot;payload.size() = %0d, pkt2cmp.payload.size() = %0d\n&quot;</span>, payload<span class="variable">.size</span>(), pkt2cmp<span class="variable">.payload</span><span class="variable">.size</span>()) &#125;;</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">foreach</span>(payload[i]) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (payload[i] == pkt2cmp<span class="variable">.payload</span>[i]) ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">      message = <span class="string">&quot;Payload Content Mismatch:\n&quot;</span>;</span><br><span class="line">      <span class="keyword">foreach</span>(payload[i])</span><br><span class="line">        message = &#123; message, <span class="built_in">$psprintf</span>(<span class="string">&quot;payload[%0d] = %0d,\tpkt2cmp.payload[%0d] = %0d\n&quot;</span>, i, payload[i], i, pkt2cmp<span class="variable">.payload</span>[i]) &#125;;</span><br><span class="line">      <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  message = <span class="string">&quot;Successfully Compared&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure><p>比较函数会比较输送队列的长度和值，不匹配会显示出问题。</p><h2><span id="driverbase">DriverBase</span></h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> DriverBase;</span><br><span class="line">  <span class="keyword">virtual</span> router_io<span class="variable">.TB</span> router;<span class="comment">// interface signal</span></span><br><span class="line">  <span class="keyword">string</span>    name;<span class="comment">// unique identifier</span></span><br><span class="line">  <span class="keyword">bit</span>[<span class="number">3</span>:<span class="number">0</span>]  sa, da;<span class="comment">// source and destination addresses</span></span><br><span class="line">  <span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>]  payload[$];<span class="comment">// Packet payload</span></span><br><span class="line">  Packet    pkt2send;<span class="comment">// stimulus Packet object</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;DriverBase&quot;</span>, <span class="keyword">virtual</span> router_io<span class="variable">.TB</span> router);</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">task</span> send();</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">task</span> send_addrs();</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">task</span> send_pad();</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">task</span> send_payload();</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure><p>driverbase是driver的父类，定义了发送任务，与时序图相对应有是三个阶段，包括传送地址、打拍以及传送数据。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> DriverBase::send_addrs();</span><br><span class="line">  <span class="keyword">if</span> (TRACE_ON) <span class="built_in">$display</span>(<span class="string">&quot;[TRACE]%t %s:%m&quot;</span>, <span class="built_in">$realtime</span>, name);</span><br><span class="line">  router<span class="variable">.cb</span><span class="variable">.frame_n</span>[sa] &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) <span class="keyword">begin</span></span><br><span class="line">    router<span class="variable">.cb</span><span class="variable">.din</span>[sa] &lt;= da[i];</span><br><span class="line">    @(router<span class="variable">.cb</span>);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> DriverBase::send_pad();</span><br><span class="line">  <span class="keyword">if</span> (TRACE_ON) <span class="built_in">$display</span>(<span class="string">&quot;[TRACE]%t %s:%m&quot;</span>, <span class="built_in">$realtime</span>, name);</span><br><span class="line">  router<span class="variable">.cb</span><span class="variable">.din</span>[sa] &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">  router<span class="variable">.cb</span><span class="variable">.valid_n</span>[sa] &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">  <span class="keyword">repeat</span>(<span class="number">5</span>) @(router<span class="variable">.cb</span>);</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> DriverBase::send_payload();</span><br><span class="line">  <span class="keyword">if</span> (TRACE_ON) <span class="built_in">$display</span>(<span class="string">&quot;[TRACE]%t %s:%m&quot;</span>, <span class="built_in">$realtime</span>, name);</span><br><span class="line">  <span class="keyword">foreach</span>(payload[index]) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) <span class="keyword">begin</span></span><br><span class="line">      router<span class="variable">.cb</span><span class="variable">.din</span>[sa] &lt;= payload[index][i];</span><br><span class="line">      router<span class="variable">.cb</span><span class="variable">.valid_n</span>[sa] &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">      router<span class="variable">.cb</span><span class="variable">.frame_n</span>[sa] &lt;= ((index == (payload<span class="variable">.size</span>() - <span class="number">1</span>)) &amp;&amp; (i == <span class="number">7</span>));</span><br><span class="line">      @(router<span class="variable">.cb</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  router<span class="variable">.cb</span><span class="variable">.valid_n</span>[sa] &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure><h2><span id="driver">Driver</span></h2><p>driver类在继承了driverbase的发送功能后，增加了旗语和信箱，用来管理进程。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Driver <span class="keyword">extends</span> DriverBase;</span><br><span class="line">  mailbox in_box;<span class="comment">// Generator mailbox</span></span><br><span class="line">  mailbox out_box;<span class="comment">// Scoreboard mailbox</span></span><br><span class="line">  semaphore sem[];<span class="comment">// output port arbitration</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;Driver&quot;</span>, <span class="keyword">int</span> port_id, semaphore sem[], mailbox in_box, out_box, <span class="keyword">virtual</span> router_io<span class="variable">.TB</span> router);</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">task</span> start();</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure><p>in_box用来存放从Generator里生成的数据，而out_box则用来将数据发送给scoreboard。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> Driver::start();</span><br><span class="line">  <span class="keyword">if</span> (TRACE_ON) <span class="built_in">$display</span>(<span class="string">&quot;[TRACE]%t %s:%m&quot;</span>, <span class="built_in">$realtime</span>, name);</span><br><span class="line">  <span class="keyword">fork</span></span><br><span class="line">    <span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">      in_box<span class="variable">.get</span>(pkt2send);</span><br><span class="line">        <span class="keyword">if</span> (pkt2send<span class="variable">.sa</span> != <span class="keyword">this</span><span class="variable">.sa</span>) <span class="keyword">continue</span>;<span class="comment">//检查源地址是否正确</span></span><br><span class="line">      <span class="keyword">this</span><span class="variable">.da</span> = pkt2send<span class="variable">.da</span>;</span><br><span class="line">      <span class="keyword">this</span><span class="variable">.payload</span> = pkt2send<span class="variable">.payload</span>;</span><br><span class="line">        sem[<span class="keyword">this</span><span class="variable">.da</span>]<span class="variable">.get</span>(<span class="number">1</span>);<span class="comment">//旗语控制一个接收地址同时只有一个在发送</span></span><br><span class="line">      send();</span><br><span class="line">      out_box<span class="variable">.put</span>(pkt2send);</span><br><span class="line">      sem[<span class="keyword">this</span><span class="variable">.da</span>]<span class="variable">.put</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">join_none</span></span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure><h2><span id="receiverbase">ReceiverBase</span></h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ReceiverBase;</span><br><span class="line">  <span class="keyword">virtual</span> router_io<span class="variable">.TB</span> router;<span class="comment">// interface signals</span></span><br><span class="line">  <span class="keyword">string</span>   name;<span class="comment">// unique identifier</span></span><br><span class="line">  <span class="keyword">bit</span>[<span class="number">3</span>:<span class="number">0</span>] da;<span class="comment">// output port to monitor</span></span><br><span class="line">  <span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] pkt2cmp_payload[$];<span class="comment">// actual payload array</span></span><br><span class="line">  Packet   pkt2cmp;<span class="comment">// actual Packet object</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;ReceiverBase&quot;</span>, <span class="keyword">virtual</span> router_io<span class="variable">.TB</span> router);</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">task</span> recv();</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">task</span> get_payload();</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure><p>包括两个任务，接收以及获取数值</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> ReceiverBase::recv();</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> pkt_cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (TRACE_ON) <span class="built_in">$display</span>(<span class="string">&quot;[TRACE]%t %s:%m&quot;</span>, <span class="built_in">$realtime</span>, name);</span><br><span class="line">  get_payload();</span><br><span class="line">  pkt2cmp<span class="variable">.da</span> = da;</span><br><span class="line">  pkt2cmp<span class="variable">.payload</span> = pkt2cmp_payload;<span class="comment">//将传输队列的值赋值给实际的包</span></span><br><span class="line">  pkt2cmp<span class="variable">.name</span> = <span class="built_in">$psprintf</span>(<span class="string">&quot;rcvdPkt[%0d]&quot;</span>, pkt_cnt++);</span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure><p>任务get_payload()</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> ReceiverBase::get_payload();</span><br><span class="line">  <span class="keyword">if</span> (TRACE_ON) <span class="built_in">$display</span>(<span class="string">&quot;[TRACE]%t %s:%m&quot;</span>, <span class="built_in">$realtime</span>, name);</span><br><span class="line">  pkt2cmp_payload<span class="variable">.delete</span>();</span><br><span class="line">  <span class="keyword">fork</span>: frameo_wd_timer</span><br><span class="line">      @(<span class="keyword">negedge</span> router<span class="variable">.cb</span><span class="variable">.frameo_n</span>[da]);<span class="comment">//一旦有下降沿，说明程序可以正常工作，跳出wd</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">      <span class="keyword">repeat</span>(<span class="number">1000</span>) @(router<span class="variable">.cb</span>);</span><br><span class="line">      <span class="built_in">$display</span>(<span class="string">&quot;\n%m\n[ERROR]%t Frame signal timed out!\n&quot;</span>, <span class="built_in">$realtime</span>);</span><br><span class="line">      <span class="built_in">$finish</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">join_any</span>: frameo_wd_timer</span><br><span class="line">  <span class="keyword">disable</span> <span class="keyword">fork</span>;</span><br><span class="line">  <span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] datum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; ) <span class="keyword">begin</span></span><br><span class="line">      <span class="keyword">if</span> (!router<span class="variable">.cb</span><span class="variable">.valido_n</span>[da])</span><br><span class="line">        datum[i++] = router<span class="variable">.cb</span><span class="variable">.dout</span>[da];</span><br><span class="line">      <span class="keyword">if</span> (router<span class="variable">.cb</span><span class="variable">.frameo_n</span>[da])</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">8</span>) <span class="keyword">begin</span></span><br><span class="line">          pkt2cmp_payload<span class="variable">.push_back</span>(datum);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">          <span class="built_in">$display</span>(<span class="string">&quot;\n%m\n[ERROR]%t Packet payload not byte aligned!\n&quot;</span>, <span class="built_in">$realtime</span>);</span><br><span class="line">          <span class="built_in">$finish</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      @(router<span class="variable">.cb</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    pkt2cmp_payload<span class="variable">.push_back</span>(datum);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure><h2><span id="receiver">Receiver</span></h2><p>receiver在receiverbase的基础上加了一个放进信箱的过程</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> Receiver::start();</span><br><span class="line">  <span class="keyword">if</span> (TRACE_ON) <span class="built_in">$display</span>(<span class="string">&quot;[TRACE]%t %s:%m&quot;</span>, <span class="built_in">$realtime</span>, name);</span><br><span class="line">  <span class="keyword">fork</span></span><br><span class="line">    <span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">      recv();</span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">        Packet pkt = <span class="keyword">new</span> pkt2cmp;</span><br><span class="line">          out_box<span class="variable">.put</span>(pkt);<span class="comment">//将pkt2cmp放进了scoreboard的信箱里</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">join_none</span></span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure><h2><span id="generator">Generator</span></h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Generator;</span><br><span class="line">  <span class="keyword">string</span>  name;<span class="comment">// unique identifier</span></span><br><span class="line">  Packet  pkt2send;<span class="comment">// stimulus Packet object</span></span><br><span class="line">  mailbox out_box[];<span class="comment">// mailbox to Drivers</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;Generator&quot;</span>);</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">task</span> gen();</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">task</span> start();</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure><p>其中，generator会生成提供给driver的out_box</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Generator::<span class="keyword">new</span>(<span class="keyword">string</span> name);</span><br><span class="line">  <span class="keyword">if</span> (TRACE_ON) <span class="built_in">$display</span>(<span class="string">&quot;[TRACE]%t %s:%m&quot;</span>, <span class="built_in">$realtime</span>, name);</span><br><span class="line">  <span class="keyword">this</span><span class="variable">.name</span> = name;</span><br><span class="line">  <span class="keyword">this</span><span class="variable">.pkt2send</span> = <span class="keyword">new</span>();</span><br><span class="line">  <span class="keyword">this</span><span class="variable">.out_box</span> = <span class="keyword">new</span>[<span class="number">16</span>];</span><br><span class="line">  <span class="keyword">foreach</span>(<span class="keyword">this</span><span class="variable">.out_box</span>[i])</span><br><span class="line">    <span class="keyword">this</span><span class="variable">.out_box</span>[i] = <span class="keyword">new</span>();</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure><h2><span id="scoreboard">Scoreboard</span></h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Scoreboard;</span><br><span class="line">  <span class="keyword">string</span>   name;<span class="comment">// unique identifier</span></span><br><span class="line">  <span class="keyword">event</span>    DONE;<span class="comment">// flag to indicate goal reached</span></span><br><span class="line">  Packet   refPkt[$];<span class="comment">// reference Packet array</span></span><br><span class="line">  Packet   pkt2send;<span class="comment">// Packet object from Drivers</span></span><br><span class="line">  Packet   pkt2cmp;<span class="comment">// Packet object from Receivers</span></span><br><span class="line">  mailbox  driver_mbox;<span class="comment">// mailbox for Packet objects from Drivers</span></span><br><span class="line">  mailbox  receiver_mbox;<span class="comment">// mailbox fro Packet objects from Receivers</span></span><br><span class="line">  <span class="keyword">bit</span>[<span class="number">3</span>:<span class="number">0</span>] sa, da;<span class="comment">// functional coverage properties</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">covergroup</span> router_cov;</span><br><span class="line">    <span class="keyword">coverpoint</span> sa;</span><br><span class="line">    <span class="keyword">coverpoint</span> da;       <span class="comment">//检查原地址和目标地址</span></span><br><span class="line">    <span class="keyword">cross</span> sa, da;</span><br><span class="line">  <span class="keyword">endgroup</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;Scoreboard&quot;</span>, mailbox driver_mbox = <span class="literal">null</span>, receiver_mbox = <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">task</span> start();</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">virtual</span> <span class="keyword">task</span> check();</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> Scoreboard::check();</span><br><span class="line">  <span class="keyword">int</span>    index[$];</span><br><span class="line">  <span class="keyword">string</span> message;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span>  pkts_checked = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">real</span>   coverage_result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (TRACE_ON) <span class="built_in">$display</span>(<span class="string">&quot;[TRACE]%0t %s:%m&quot;</span>, <span class="built_in">$time</span>, name);</span><br><span class="line">  index = refPkt<span class="variable">.find_first_index</span>() <span class="keyword">with</span> (item<span class="variable">.da</span> == pkt2cmp<span class="variable">.da</span>);</span><br><span class="line">  <span class="keyword">if</span> (index<span class="variable">.size</span>() &lt;= <span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;\n%m\n[ERROR]%0t %s not found in Reference Queue\n&quot;</span>, <span class="built_in">$time</span>, pkt2cmp<span class="variable">.name</span>);</span><br><span class="line">    pkt2cmp<span class="variable">.display</span>(<span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">    <span class="built_in">$finish</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  pkt2send = refPkt[index[<span class="number">0</span>]];</span><br><span class="line">  refPkt<span class="variable">.delete</span>(index[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">if</span> (!pkt2send<span class="variable">.compare</span>(pkt2cmp, message)) <span class="keyword">begin</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;\n%m\n[ERROR]%0t Packet #%0d %s\n&quot;</span>, <span class="built_in">$time</span>, pkts_checked, message);</span><br><span class="line">    pkt2send<span class="variable">.display</span>(<span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">    pkt2cmp<span class="variable">.display</span>(<span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">    <span class="built_in">$finish</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">this</span><span class="variable">.sa</span> = pkt2send<span class="variable">.sa</span>;</span><br><span class="line">  <span class="keyword">this</span><span class="variable">.da</span> = pkt2send<span class="variable">.da</span>;</span><br><span class="line">  router_cov<span class="variable">.sample</span>();</span><br><span class="line">  coverage_result = <span class="built_in">$get_coverage</span>();</span><br><span class="line">  <span class="built_in">$display</span>(<span class="string">&quot;[NOTE]%0t Packet #%0d %s coverage = %3.2f&quot;</span>, <span class="built_in">$time</span>, pkts_checked++, message, coverage_result);</span><br><span class="line">  <span class="keyword">if</span> ((pkts_checked &gt;= run_for_n_packets) || (coverage_result == <span class="number">100</span>))</span><br><span class="line">    -&gt;DONE;</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li><code>DUT</code>的功能和结构</li><li>根据<code>DUT</code>的功能及结构我们搭建的验证平台，为什么要这样搭建</li><li>验证平台的各个组件之间的通信，如何跟<code>DUT</code>相关联</li><li>分解测试点，都验了哪些功能，各个功能你是怎么验证的（这个可能有时候会问的比较细致）</li><li>收集覆盖率，代码覆盖率，功能覆盖率为什么才90%？你是怎么收集的？达不到 100%怎么办？</li></ul><p>__本文作者__：Yuchen <a href="http://example.com/2022/02/05/testbentch-lab/">http://example.com/2022/02/05/testbentch-lab/</a> <br>__版权声明__：转载请注明出处！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;重新用questasim跑了一下普通版的tb，理一下思路&lt;/p&gt;
&lt;p&gt;包括下面这些文件&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;文件列表&quot;&gt;文件列表&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;│  Packet.sv&lt;/p&gt;
&lt;p&gt;│  Driver.sv│  DriverBase.sv&lt;</summary>
      
    
    
    
    
    <category term="verify" scheme="http://example.com/tags/verify/"/>
    
  </entry>
  
  <entry>
    <title>电路部分</title>
    <link href="http://example.com/2021/09/15/basic/"/>
    <id>http://example.com/2021/09/15/basic/</id>
    <published>2021-09-15T13:26:42.000Z</published>
    <updated>2022-03-21T13:43:36.595Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>建立时间与保存时间</p></li><li><p>组合逻辑与时序逻辑</p></li><li><p>动态功耗与静态功耗</p></li><li><p>高电平噪声与低电平噪声</p></li><li><p>用mos管搭建逻辑门</p></li><li><p>流水线技术</p></li></ol><h1><span id="建立时间与保持时间">建立时间与保持时间</span></h1><p><img src="https://images0.cnblogs.com/i/526766/201405/111711122603954.png" alt="img"></p><p>建立时间（Tsu：set up time）　　</p><p>　　是指在触发器的==时钟信号上升沿到来以前，数据稳定不变的时间==，如果建立时间不够，数据将不能在这个时钟上升沿被稳定的打入触发器，Tsu就是指这个最小的稳定时间。</p><p>保持时间（Th：hold time）　　</p><p>　　是指在触发器的==时钟信号上升沿到来以后，数据稳定不变的时间==，如果保持时间不够，数据同样不能被稳定的打入触发器，Th就是指这个最小的保持时间。</p><p>输出相应时间（Tco）　</p><p>　　触发器输出的响应时间，也就是触发器的输出在clk时钟上升沿到来之后多长的时间内发生变化，也即触发器的输出延时。</p><p>以D触发器为例</p><p><a href="https://imgtu.com/i/4emdpT"><img src="https://z3.ax1x.com/2021/09/15/4emdpT.png" alt="4emdpT.png" style="zoom:80%;"></a></p><p>其建立时间与保持时间如图</p><p><a href="https://imgtu.com/i/4emHAI"><img src="https://z3.ax1x.com/2021/09/15/4emHAI.png" alt="4emHAI.png" style="zoom:80%;"></a></p><p>而一但在建立和保持时间中数据发生变化（C点），会导致整个时钟周期的输出处于亚稳态，介于0-1之间。</p><p>一个例子是串联的两个D触发器和中间的逻辑电路</p><img src="https://images0.cnblogs.com/i/526766/201405/111717378543354.png" alt="img" style="zoom:80%;"><p><em><strong>*第二个触发器要满足建立时间的约束条件*</strong></em></p><p>时序图如下，假设D1的输入为图中的蓝线所示</p><img src="https://images0.cnblogs.com/i/526766/201405/111723242609983.png" alt="img" style="zoom:80%;"><p>在第一个时钟上升沿，前边的触发器采集D1信号，将高电平打入触发器，经过Tco的触发器输出延时到达组合逻辑电路。又经过组合逻辑电路的延时Tcomb（我们假定组合逻辑电路此时没有改变信号的高低，可以把它假定为一个缓冲器）送到了D2接口上。在第二个时钟上升沿到来之前，D2数据线上的信号要满足稳定时间&gt;触发器的建立时间Tsu。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tclk - Tco - Tcomb &gt; Tsu</span><br></pre></td></tr></table></figure><p><em><strong>*第二个触发器要满足保持时间的约束条件*</strong></em></p><img src="https://images0.cnblogs.com/i/526766/201405/111737150268286.png" alt="img" style="zoom:80%;"><p> 接着之前的时序图继续，在第二个时钟上升沿前边触发器采集到D1上的低电平，经过Tco的延时在Q1上得到表达。这个低电平在经过组合电路延时Tcomb到达D2。现在的问题是经过这么Tco+Tcomb的延时，D2上原本的高电平在第二个时钟上升沿到来之后的稳定时间 &gt; 第二个触发器的保持时间。满足了这个条件，后边的触发器才能稳定的接收到最初由D1传过来的高电平。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tco + Tcomb &gt; Th</span><br></pre></td></tr></table></figure><h1><span id="用mos管搭建逻辑门">用mos管搭建逻辑门</span></h1><p>NMOS:高电平截止</p><p>PMOS:高电平导通</p><p><img src="http://mouser.eetrend.com/files/2020-11/wen_zhang_/100059002-113259-11.png" alt="“”"></p><blockquote><p>用1个NMOS和1个PMOS搭建的非门；当A为高电平时，T1截止，T2导通，Y为低电平；当A为低电平时，T1导通，T2截止，Y为高电平。</p></blockquote><p><img src="http://mouser.eetrend.com/files/2020-11/wen_zhang_/100059002-113259-11.png" alt="“”"></p><blockquote><p>② MOS管与非门</p><p>备注：T3和T4为NMOS，T5和T6为PMOS；</p><p>A=0，B=0时，T5和T6导通，T3和T4截止，Y=1</p><p>A=1，B=0时，T3和T6截止，T4和T5导通，Y=1</p><p>A=0，B=1时，T3和T6导通，T4和T5截止，Y=1</p><p>A=1，B=1时，T5和T6截止，T3和T4导通，Y=0</p></blockquote><h1><span id="动态功耗与静态功耗">动态功耗与静态功耗</span></h1><p>动态功耗主要有开关功耗和短路功耗；其中开关功耗在动态功耗中占大部分比例；从上面的两个式子中我们可以看到，动态功耗主要跟电源的供电电压、翻转率、负载电容有关。</p><p>在CMOS电路中，静态功耗主要是漏电流引起的功耗，如下图所示：</p><img src="https://images2015.cnblogs.com/blog/1110317/201705/1110317-20170523130648132-563339299.png" alt="img" style="zoom:80%;"><p>漏电流有下面几个部分组成：</p><p>　　·PN结反向电流I1（PN-junction Reverse Current）</p><p>　　·源极和漏极之间的亚阈值漏电流I2（Sub-threshold Current）</p><p>　　·栅极漏电流，包括栅极和漏极之间的感应漏电流I3（Gate Induced Drain Leakage）</p><p>　　·栅极和衬底之间的隧道漏电流I4（Gate Tunneling）</p><h1><span id="组合逻辑与时序逻辑">组合逻辑与时序逻辑</span></h1><p>1、简单说，组合逻辑只跟当前的状态有关系，例如一根导线 + 逻辑门的组合，输出取决于当前时刻的输入，考虑门延时的话另说。</p><p>2、时序逻辑的状态跟之前状态、边沿信号有关，边沿信号没来之前，输出保持之前的输入；边沿信号来时，输出状态跟随输入信号变化。</p><h1><span id="电平噪声">电平噪声</span></h1><p>当一个信号上叠加了噪声后，其电平会发生变化，但是叠加多少噪声后其逻辑值会发生变化呢？<strong>逻辑值不发生变化时，电路所能够容忍的最大噪声值就是噪声容限</strong>。</p><p><a href="https://imgtu.com/i/4e8sBT"><img src="https://z3.ax1x.com/2021/09/16/4e8sBT.png" alt="4e8sBT.png"></a></p><h1><span id="流水线">流水线</span></h1><p><a href="https://blog.csdn.net/rill_zhen/article/details/8038697">https://blog.csdn.net/rill_zhen/article/details/8038697</a></p><p>核心是用面积换速度。</p><p>__本文作者__：Yuchen <a href="http://example.com/2021/09/15/basic/">http://example.com/2021/09/15/basic/</a> <br>__版权声明__：转载请注明出处！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;建立时间与保存时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;组合逻辑与时序逻辑&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态功耗与静态功耗&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;高电平噪声与低电平噪声&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用mos管搭建逻辑门&lt;/p&gt;
&lt;/l</summary>
      
    
    
    
    
    <category term="ic" scheme="http://example.com/tags/ic/"/>
    
  </entry>
  
  <entry>
    <title>UVM_LAB 5</title>
    <link href="http://example.com/2021/09/07/5/"/>
    <id>http://example.com/2021/09/07/5/</id>
    <published>2021-09-07T10:36:53.000Z</published>
    <updated>2021-09-07T14:02:41.588Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="重置sequence">重置Sequence</span></h2><p>首先需要创建一个顶层的reset_sequence来管理下面的reset_sequence 和router_input_port_reset_sequence的执行。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> top_reset_sequence <span class="keyword">extends</span> uvm_sequence;</span><br><span class="line">  <span class="meta">`uvm_object_utils(top_reset_sequence)</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">`uvm_declare_p_sequencer(top_reset_sequencer)</span></span><br><span class="line"></span><br><span class="line">  reset_sequence                    r_seq;</span><br><span class="line">  router_input_port_reset_sequence  i_seq;</span><br></pre></td></tr></table></figure><p>因此使用virtual sequence进行进度管理。</p><p>创建一个q_sequence指针，用来指向top_reset_sequencer中的两个sequence。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fork</span></span><br><span class="line">  <span class="meta">`uvm_do_on(r_seq, p_sequencer.r_sqr);</span></span><br><span class="line">  <span class="keyword">foreach</span> (p_sequencer<span class="variable">.pkt_sqr</span>[i]) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">fork</span></span><br><span class="line">      <span class="keyword">int</span> j = i;</span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">        reset_event<span class="variable">.wait_on</span>();</span><br><span class="line">        <span class="meta">`uvm_do_on(i_seq, p_sequencer.pkt_sqr[j]);</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">join_none</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">join</span></span><br></pre></td></tr></table></figure><p>之后现将r_seq发送给r_sqr，再遍历pkt_sqr，执行i_seq。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uvm_config_db <span class="variable">#(uvm_object_wrapper)::set(this, &quot;env.r_agt.sqr.reset_phase&quot;, &quot;default_sequence&quot;, null)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uvm_config_db <span class="variable">#(uvm_object_wrapper)::set(this, &quot;env.i_agt[*].sqr.reset_phase&quot;, &quot;default_sequence&quot;, null)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uvm_config_db <span class="variable">#(uvm_object_wrapper)::set(this, &quot;top_reset_sqr.reset_phase&quot;, &quot;default_sequence&quot;, top_reset_sequence::get_type())</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>取消之前的设置，并将top_reset_sqr的reset_phase设为执行top_reset_sequence。</p><p>关于 uvm_config_db #(uvm_object_wrapper)::set</p><blockquote><p>uvm_config_db#(int)::set(this, “env.i_agt.drv”, “pre_num”, 100);</p><p>四个参数，set寄信，get收信。</p><p>第一个和第二个参数联合起来组成目标路径，与此路径符合的目标才能收信。第一个参数必须是一个uvm_component实例的指针，第二个参数是相对此实例的路径。第三个参数表示一个记号，用以说明这个值是传给目标中的哪个成员的，第四个参数是要设置的值。</p><p>uvm_config_db#(int)::get(this, “”, “pre_num”, pre_num);</p><p>四个参数中，第一个参数，通常可以为 “this”, “null”等实例的指针。</p><p>第二个参数，可以为空“”， 也可以用通配符，如截图中的例子，”*yy_agent” “yy_agent.drv”</p><p>set 与get的第一个到第三个参数“寄信”与“收信”要符合两个条件：时间的匹配，一定是先寄信再收信，为了避免出错，一般get前最好加判断，2 标记一致，也就是邮件目的地是匹配的。</p><p>第三个，往往是个参数值，或者说句柄。</p></blockquote><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (env<span class="variable">.i_agt</span>[i]) <span class="keyword">begin</span></span><br><span class="line">  top_reset_sqr<span class="variable">.pkt_sqr</span><span class="variable">.push_back</span>(env<span class="variable">.i_agt</span>[i]<span class="variable">.sqr</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>将i_agt的sequencer放入pkt_sqr，需要注意的是这是一个队列。</p><p>再将r_sqr的指针指向r_agt.sqr。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top_reset_sqr<span class="variable">.r_sqr</span> = env<span class="variable">.r_agt</span><span class="variable">.sqr</span>;</span><br></pre></td></tr></table></figure><p>在reset_monitor中，有一个使用了断言的detect()</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> <span class="keyword">task</span> detect(reset_tr tr);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line">    @(vif<span class="variable">.reset_n</span>);</span><br><span class="line">    <span class="keyword">assert</span>(!<span class="built_in">$isunknown</span>(vif<span class="variable">.reset_n</span>));</span><br><span class="line">    <span class="keyword">if</span> (vif<span class="variable">.reset_n</span> == <span class="number">1&#x27;b0</span>) <span class="keyword">begin</span></span><br><span class="line">      tr<span class="variable">.kind</span> = reset_tr::ASSERT;</span><br><span class="line">      reset_event<span class="variable">.trigger</span>();</span><br><span class="line">        <span class="comment">//触发reset</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">      tr<span class="variable">.kind</span> = reset_tr::DEASSERT;</span><br><span class="line">      reset_event<span class="variable">.reset</span>();</span><br><span class="line">        <span class="comment">//reset关闭</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">endtask</span>: detect</span><br></pre></td></tr></table></figure><p>$isunknown()这个函数的作用是，当声明内容中有x或z时 返回1</p><p>__本文作者__：Yuchen <a href="http://example.com/2021/09/07/5/">http://example.com/2021/09/07/5/</a> <br>__版权声明__：转载请注明出处！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2&gt;&lt;span id=&quot;重置sequence&quot;&gt;重置Sequence&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;首先需要创建一个顶层的reset_sequence来管理下面的reset_sequence 和router_input_port_reset_sequence的执行。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="uvm" scheme="http://example.com/tags/uvm/"/>
    
  </entry>
  
  <entry>
    <title>UVM_LAB 4</title>
    <link href="http://example.com/2021/09/06/4/"/>
    <id>http://example.com/2021/09/06/4/</id>
    <published>2021-09-06T12:24:54.000Z</published>
    <updated>2021-09-07T10:35:58.070Z</updated>
    
    <content type="html"><![CDATA[<p>在第四个lab中我们需要加入monitor和scoreboard来自检</p><h2><span id="monitor">Monitor</span></h2><p>需要有两个monitor，一个监控输入dut的信号，称为iMontor；一个监控dut输出的信号，称为OMonitor。</p><h3><span id="imonitor">iMonitor</span></h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uvm_analysis_port <span class="variable">#(packet)</span> analysis_port;<span class="comment">//创建端口</span></span><br><span class="line">analysis_port = <span class="keyword">new</span>(<span class="string">&quot;analysis_port&quot;</span>, <span class="keyword">this</span>);<span class="comment">//初始化端口</span></span><br></pre></td></tr></table></figure><p>由于TLM端口在UVM中没有factory机制，因此只能用new()而不能用create()。</p><h4><span id="run_phase">run_phase</span></h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> <span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line"></span><br><span class="line">  packet tr;</span><br><span class="line">  <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">  </span><br><span class="line">    tr = packet::type_id::create(<span class="string">&quot;tr&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    tr<span class="variable">.sa</span> = <span class="keyword">this</span><span class="variable">.port_id</span>;</span><br><span class="line">    get_packet(tr);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;Got_Input_Packet&quot;, &#123;&quot;\n&quot;, tr.sprint()&#125;, UVM_MEDIUM);</span></span><br><span class="line">    analysis_port<span class="variable">.write</span>(tr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span>: run_phase</span><br></pre></td></tr></table></figure><p>输入监视器的作用是观察各个端口的输入信号，并将他们储存在一个对象tr中。</p><p>设置源地址字段后，调用get_packet()检索观察到的trans。然后，显示观察到的事务的内容，并通过调用其write()方法，通过TLM分析端口(analysis_port)将观察到的事务传递给所有其他感兴趣的组件。</p><h4><span id="get_packet">Get_packet</span></h4><img src="https://img-blog.csdnimg.cn/20190815160900760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoaUFva2Fp,size_16,color_FFFFFF,t_70" alt="img" style="zoom:67%;"><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wait</span> (vif<span class="variable">.iMonClk</span><span class="variable">.frame_n</span>[port_id] !==<span class="number">0</span>);</span><br><span class="line">  @(vif<span class="variable">.iMonClk</span> <span class="keyword">iff</span> (vif<span class="variable">.iMonClk</span><span class="variable">.frame_n</span>[port_id] === <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>等待阶段，等待frame_n拉高开始准备，等frame_n拉低时开始，其中iff的用法如下</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@(<span class="keyword">posedge</span> clk <span class="keyword">iff</span>(vld));</span><br><span class="line">do_something;</span><br></pre></td></tr></table></figure><p>等于</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">@(<span class="keyword">posedge</span> clk);</span><br><span class="line"><span class="keyword">if</span>(vld)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">do_something;</span><br></pre></td></tr></table></figure><p>但事件表达式仅仅在 <code>iff</code> 之后的表达式为真时才会触发，在上面的例子中就是 <code>vld</code> 等于 1 的情况。注意：这个表达式只有在 <code>vld</code> 发生变化时计算，而不是 <code>clk</code> 发生变化的时候。</p><p>记录目标地址</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">if</span> (!vif<span class="variable">.iMonClk</span><span class="variable">.frame_n</span>[port_id]) <span class="keyword">begin</span></span><br><span class="line">    tr<span class="variable">.da</span>[i] = vif<span class="variable">.iMonClk</span><span class="variable">.din</span>[port_id];</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="meta">`uvm_fatal(&quot;Header_Error&quot;, $sformatf(&quot;@ Header cycle %0d, Frame not zero&quot;, i));</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  @(vif<span class="variable">.iMonClk</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>有效性检查</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">if</span> (!vif<span class="variable">.iMonClk</span><span class="variable">.frame_n</span>[port_id]) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (vif<span class="variable">.iMonClk</span><span class="variable">.valid_n</span>[port_id] &amp;&amp; vif<span class="variable">.iMonClk</span><span class="variable">.din</span>[port_id]) <span class="keyword">begin</span></span><br><span class="line">      @(vif<span class="variable">.iMonClk</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">      <span class="meta">`uvm_fatal(&quot;Header_Error&quot;, $sformatf(&quot;@%0d Valid or Din zero&quot;, i));</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="meta">`uvm_fatal(&quot;Header_Error&quot;, &quot;Frame not zero&quot;);</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>记录数据</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i=i) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!vif<span class="variable">.iMonClk</span><span class="variable">.valid_n</span>[port_id]) <span class="keyword">begin</span></span><br><span class="line">      <span class="keyword">if</span> (vif<span class="variable">.iMonClk</span><span class="variable">.busy_n</span>[port_id]) <span class="keyword">begin</span></span><br><span class="line">        datum[i++] = vif<span class="variable">.iMonClk</span><span class="variable">.din</span>[port_id];</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">8</span>) <span class="keyword">begin</span></span><br><span class="line">          tr<span class="variable">.payload</span><span class="variable">.push_back</span>(datum);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="meta">`uvm_fatal(&quot;Payload_Error&quot;, &quot;Busy &amp; Valid conflict&quot;);</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> (vif<span class="variable">.iMonClk</span><span class="variable">.frame_n</span>[port_id]) <span class="keyword">begin</span></span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">8</span>) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="meta">`uvm_fatal(&quot;Payload_Error&quot;, &quot;Not byte aligned&quot;);</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    @(vif<span class="variable">.iMonClk</span>);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>之后再input_agent中加入端口和monitor，使用is_active来判断agent状态，再例化组件</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iMonitor mon;</span><br><span class="line">uvm_analysis_port <span class="variable">#(packet)</span> analysis_port;</span><br></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_active == UVM_ACTIVE) <span class="keyword">begin</span></span><br><span class="line">sqr = packet_sequencer::type_id::create(<span class="string">&quot;sqr&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">drv = driver::type_id::create(<span class="string">&quot;drv&quot;</span>, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>在任何状态下例化monitor和port</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mon = iMonitor::type_id::create(<span class="string">&quot;mon&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">analysis_port = <span class="keyword">new</span>(<span class="string">&quot;analysis_port&quot;</span>, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>连接driver和sequencer的端口</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_active == UVM_ACTIVE) <span class="keyword">begin</span></span><br><span class="line">  drv<span class="variable">.seq_item_port</span><span class="variable">.connect</span>(sqr<span class="variable">.seq_item_export</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>连接monitor的分析端口和agent的分析端口</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mon<span class="variable">.analysis_port</span><span class="variable">.connect</span>(<span class="keyword">this</span><span class="variable">.analysis_port</span>);</span><br></pre></td></tr></table></figure><h2><span id="environment">Environment</span></h2><p>创建对应的组件</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input_agent i_agt[<span class="number">16</span>];</span><br><span class="line">scoreboard sb;<span class="comment">//伞兵</span></span><br><span class="line">output_agent o_agt[<span class="number">16</span>];</span><br></pre></td></tr></table></figure><p>配置初始化阶段执行的sequence，主阶段执行另一个sequence</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (i_agt[i]) <span class="keyword">begin</span></span><br><span class="line">  i_agt[i] = input_agent::type_id::create(<span class="built_in">$sformatf</span>(<span class="string">&quot;i_agt[%0d]&quot;</span>, i), <span class="keyword">this</span>);</span><br><span class="line">  uvm_config_db <span class="variable">#(int)::set(this, i_agt[i].get_name(), &quot;port_id&quot;, i)</span>;</span><br><span class="line">  uvm_config_db <span class="variable">#(uvm_object_wrapper)::set(this, &#123;i_agt[i].get_name(), &quot;.&quot;, &quot;sqr.reset_phase&quot;&#125;, &quot;default_sequence&quot;, router_input_port_reset_sequence::get_type())</span>;</span><br><span class="line">  uvm_config_db <span class="variable">#(uvm_object_wrapper)::set(this, &#123;i_agt[i].get_name(), &quot;.&quot;, &quot;sqr.main_phase&quot;&#125;, &quot;default_sequence&quot;, packet_sequence::get_type())</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>连接agent到sb</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (i_agt[i]) <span class="keyword">begin</span></span><br><span class="line">  i_agt[i]<span class="variable">.analysis_port</span><span class="variable">.connect</span>(sb<span class="variable">.before_export</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">foreach</span> (o_agt[i]) <span class="keyword">begin</span></span><br><span class="line">  o_agt[i]<span class="variable">.analysis_port</span><span class="variable">.connect</span>(sb<span class="variable">.after_export</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2><span id="scoreboard">Scoreboard</span></h2><p>创建两个端口，用于连接iMonitor和oMonitor。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uvm_analysis_export <span class="variable">#(packet)</span> before_export;</span><br><span class="line">uvm_analysis_export <span class="variable">#(packet)</span> after_export;</span><br></pre></td></tr></table></figure><p>连接</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span><span class="variable">.before_export</span><span class="variable">.connect</span>(comparator<span class="variable">.before_export</span>);</span><br><span class="line"><span class="keyword">this</span><span class="variable">.after_export</span><span class="variable">.connect</span>(comparator<span class="variable">.after_export</span>); </span><br></pre></td></tr></table></figure><h2><span id="test_collection">Test_collection</span></h2><p>改变agent配置</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uvm_config_db<span class="variable">#(virtual router_io)::set(this, &quot;env.i_agt[*]&quot;, &quot;vif&quot;, router_vif)</span>;</span><br><span class="line"></span><br><span class="line"> uvm_config_db<span class="variable">#(virtual router_io)::set(this, &quot;env.o_agt[*]&quot;, &quot;vif&quot;, router_vif)</span>;</span><br><span class="line"></span><br><span class="line"> uvm_config_db<span class="variable">#(virtual reset_io)::set(this, &quot;env.r_agt&quot;, &quot;vif&quot;, reset_vif)</span>;</span><br></pre></td></tr></table></figure><p>Shut_down phase</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> <span class="keyword">task</span> shutdown_phase(uvm_phase phase);</span><br><span class="line">  <span class="keyword">super</span><span class="variable">.shutdown_phase</span>(phase);</span><br><span class="line">  <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line"></span><br><span class="line">  phase<span class="variable">.raise_objection</span>(<span class="keyword">this</span>);</span><br><span class="line">  env<span class="variable">.sb</span><span class="variable">.wait_for_done</span>();</span><br><span class="line">  phase<span class="variable">.drop_objection</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endtask</span>: shutdown_phase</span><br></pre></td></tr></table></figure><p>==这样的测试存在一个问题，就是当生成了160个包，但实际只会输出159个包，也就是会丢掉一个包。==</p><p>问题在于object这个机制是在input的位置raise和drop的，一旦输入完成，uvm就认为模拟结束了。</p><p>有几种办法可以解决这个问题，一种是设置drain time，具体可以参考。简单来说就是在drop object和结束模拟之间加一段时间，从而解决延迟的问题。</p><blockquote><p>关于drain time 可以看这个博客</p><p><a href="https://blog.verificationgentleman.com/2014/04/uvm-drain-time-old-fashioned-way.html">https://blog.verificationgentleman.com/2014/04/uvm-drain-time-old-fashioned-way.html</a></p></blockquote><p>具体方法是多加一个main_phase，里面设置drain time</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> <span class="keyword">task</span> main_phase(uvm_phase phase);</span><br><span class="line">  uvm_objection objection;</span><br><span class="line">  <span class="keyword">super</span><span class="variable">.main_phase</span>(phase);</span><br><span class="line">  <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line"></span><br><span class="line">  objection = phase<span class="variable">.get_objection</span>();</span><br><span class="line">  objection<span class="variable">.set_drain_time</span>(<span class="keyword">this</span>, <span class="number">1</span>us);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endtask</span>: main_phase</span><br></pre></td></tr></table></figure><p>另一种是直接确定比较器中已经没有进程了，这种方法比较直接。</p><p>重载scoreboard</p><p>由于这个实验中确定mismatch与输入的packet的顺序有关，因此需要重载一个乱序的sb</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_type_override_by_type(scoreboard::get_type(), ms_scoreboard::get_type());</span><br></pre></td></tr></table></figure><blockquote><p>关于重载</p><p><a href="http://www.dvagent.com/forum.php?mod=viewthread&amp;tid=276">http://www.dvagent.com/forum.php?mod=viewthread&amp;tid=276</a></p></blockquote><p>这里使用了</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`uvm_analysis_imp_decl</span></span><br></pre></td></tr></table></figure><p>这个宏，具体用法见</p><blockquote><p><a href="https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/files/macros/uvm_tlm_defines-svh.html#%60uvm_analysis_imp_decl">https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.2/html/files/macros/uvm_tlm_defines-svh.html#%60uvm_analysis_imp_decl</a></p></blockquote><p>主要功能是让不同端口实现不同功能。</p><p>==在执行过程中是怎么遍历的所有的port的，他们的顺序是怎样的？==</p><p><img src="https://img-blog.csdnimg.cn/20190915213936109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1cxWjFR,size_16,color_FFFFFF,t_70" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20200912170141840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk2OTEyNA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在第四个lab中我们需要加入monitor和scoreboard来自检&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;monitor&quot;&gt;Monitor&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;需要有两个monitor，一个监控输入dut的信号，称为iMontor；一个监控dut输出的信号，称为O</summary>
      
    
    
    
    
    <category term="uvm" scheme="http://example.com/tags/uvm/"/>
    
  </entry>
  
  <entry>
    <title>UVM_LAB 3</title>
    <link href="http://example.com/2021/09/04/3/"/>
    <id>http://example.com/2021/09/04/3/</id>
    <published>2021-09-04T13:04:27.000Z</published>
    <updated>2021-09-04T15:34:55.482Z</updated>
    
    <content type="html"><![CDATA[<p>在lab3中，需要创建物理接口以及驱动。</p><h3><span id="interface">Interface</span></h3><h4><span id="port_id">port_id</span></h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> router_io vif;           <span class="comment">// DUT virtual interface</span></span><br><span class="line"><span class="keyword">int</span>     port_id = -<span class="number">1</span>;            <span class="comment">// Driver&#x27;s designated port</span></span><br></pre></td></tr></table></figure><p>这里port_id的作用是，当port_id介于0~15（dut的端口值时，driver只会驱动地址相同的packet，而当地址port_id为-1时，driver接收所有packet并将其发送到对应端口）</p><p>e.g.</p><blockquote><p>Example: If port_id is 3 and req.sa is also 3,</p><p>(req is the packet handle that sequencer passed to the driver)</p><p>The driver will drive the packet through port 3 of DUT: vif.drvClk.din[req.sa];</p><p>Example: If port_id is 3 and req.sa is 7,</p><p> The driver will drop the packet.</p><p> Example: If port_id is -1 and req.sa is 7,</p><p> The driver will drive the packet through port 7 of DUT: vif.drvClk.din[req.sa];</p></blockquote><h4><span id="接口检索">接口检索</span></h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">  <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">  <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line"></span><br><span class="line">  uvm_config_db<span class="variable">#(int)::get(this, &quot;&quot;, &quot;port_id&quot;, port_id)</span>;</span><br><span class="line">  uvm_config_db<span class="variable">#(virtual router_io)::get(this, &quot;&quot;, &quot;vif&quot;, vif)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endfunction</span>: build_phase</span><br></pre></td></tr></table></figure><p>使用uvm_config_db在config_db中检索端口以及接口。</p><h4><span id="结构检查">结构检查</span></h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> end_of_elaboration_phase(uvm_phase phase);</span><br><span class="line">  <span class="keyword">super</span><span class="variable">.end_of_elaboration_phase</span>(phase);</span><br><span class="line">  <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(port_id <span class="keyword">inside</span> &#123;-<span class="number">1</span>, [<span class="number">0</span>:<span class="number">15</span>]&#125;)) <span class="keyword">begin</span></span><br><span class="line">    <span class="meta">`uvm_fatal(&quot;CFGERR&quot;, $sformatf(&quot;port_id must be &#123;-1, [0:15]&#125;, not %0d!&quot;, port_id));</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">if</span> (vif == <span class="literal">null</span>) <span class="keyword">begin</span></span><br><span class="line">    <span class="meta">`uvm_fatal(&quot;CFGERR&quot;, &quot;Interface for Driver not set&quot;);</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endfunction</span>: end_of_elaboration_phase</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用end_of_elaboration_phase来检查tb的结构以及变量，具体来说就是检查端口数值范围以及接口设定。</p><h4><span id="将interface放进db中">将interface放进db中</span></h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> uvm_resource_db<span class="variable">#(virtual router_io)::set(&quot;router_vif&quot;, &quot;&quot;, router_test_top.router_if)</span>;</span><br><span class="line"> uvm_resource_db<span class="variable">#(virtual reset_io)</span>::set(<span class="string">&quot;reset_vif&quot;</span>, <span class="string">&quot;&quot;</span>,</span><br><span class="line">router_test_top<span class="variable">.reset_if</span>);</span><br></pre></td></tr></table></figure><h3><span id="driver">Driver</span></h3><p>使用了send函数来发送数据，其中又包括三个task</p><img src="https://img-blog.csdnimg.cn/20190815160900760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoaUFva2Fp,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;"><h4><span id="send_address">send_address</span></h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> <span class="keyword">task</span> send_address(packet tr);</span><br><span class="line">  <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line">    vif<span class="variable">.drvClk</span><span class="variable">.frame_n</span>[tr<span class="variable">.sa</span>] &lt;= <span class="number">1&#x27;b0</span>;<span class="comment">//拉低frame_n，开始传输地址</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) <span class="keyword">begin</span></span><br><span class="line">    vif<span class="variable">.drvClk</span><span class="variable">.din</span>[tr<span class="variable">.sa</span>] &lt;= tr<span class="variable">.da</span>[i];</span><br><span class="line">    @(vif<span class="variable">.drvClk</span>);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span>: send_address</span><br></pre></td></tr></table></figure><h4><span id="send_pad">send_pad</span></h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> <span class="keyword">task</span> send_pad(packet tr);</span><br><span class="line">  <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line">  vif<span class="variable">.drvClk</span><span class="variable">.din</span>[tr<span class="variable">.sa</span>] &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">  vif<span class="variable">.drvClk</span><span class="variable">.valid_n</span>[tr<span class="variable">.sa</span>] &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">repeat</span>(<span class="number">5</span>) @(vif<span class="variable">.drvClk</span>);<span class="comment">//valid_n和din拉高，打5拍</span></span><br><span class="line"><span class="keyword">endtask</span>: send_pad</span><br></pre></td></tr></table></figure><h4><span id="send_payload">send_payload</span></h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> <span class="keyword">task</span> send_payload(packet tr);</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] datum;</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line">    <span class="keyword">while</span>(!vif<span class="variable">.drvClk</span><span class="variable">.busy_n</span>[tr<span class="variable">.sa</span>]) @(vif<span class="variable">.drvClk</span>);<span class="comment">//检查端口是否繁忙</span></span><br><span class="line">    <span class="keyword">foreach</span>(tr<span class="variable">.payload</span>[index]) <span class="keyword">begin</span></span><br><span class="line">      datum = tr<span class="variable">.payload</span>[index];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">$size</span>(tr<span class="variable">.payload</span>, <span class="number">2</span>); i++) <span class="keyword">begin</span></span><br><span class="line">        vif<span class="variable">.drvClk</span><span class="variable">.din</span>[tr<span class="variable">.sa</span>] &lt;= datum[i];</span><br><span class="line">        vif<span class="variable">.drvClk</span><span class="variable">.valid_n</span>[tr<span class="variable">.sa</span>] &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        vif<span class="variable">.drvClk</span><span class="variable">.frame_n</span>[tr<span class="variable">.sa</span>] &lt;= ((tr<span class="variable">.payload</span><span class="variable">.size</span>()-<span class="number">1</span>) == index) &amp;&amp; (i==<span class="number">7</span>);</span><br><span class="line">          <span class="comment">//所有数据发送完了frame_n拉高</span></span><br><span class="line">        @(vif<span class="variable">.drvClk</span>);</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    vif<span class="variable">.drvClk</span><span class="variable">.valid_n</span>[tr<span class="variable">.sa</span>] &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">  <span class="keyword">endtask</span>: send_payload</span><br></pre></td></tr></table></figure><h3><span id="reset">Reset</span></h3><p>一个reset_agent中包括reset sequencer, driver and monitor。</p><h4><span id="reset_trans">reset_trans</span></h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> reset_tr <span class="keyword">extends</span> uvm_sequence_item;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;ASSERT, DEASSERT&#125; kind_e;<span class="comment">//定义枚举</span></span><br><span class="line">  <span class="keyword">rand</span> kind_e kind;</span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">int</span> <span class="keyword">unsigned</span> cycles = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">`uvm_object_utils_begin(reset_tr)</span></span><br><span class="line">    <span class="meta">`uvm_field_enum(kind_e, kind, UVM_ALL_ON)</span></span><br><span class="line">    <span class="meta">`uvm_field_int(cycles, UVM_ALL_ON)</span></span><br><span class="line">  <span class="meta">`uvm_object_utils_end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;reset_tr&quot;</span>);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line">  <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure><h4><span id="reset_sequencer">reset_sequencer</span></h4><p>在lab3中，实验提供了reset_trans用以重置dut。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> reset_sequence <span class="keyword">extends</span> uvm_sequence <span class="variable">#(reset_tr)</span>;</span><br><span class="line">  <span class="meta">`uvm_object_utils(reset_sequence)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;reset_sequence&quot;</span>);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">`<span class="meta-keyword">ifndef</span> UVM_VERSION_1_1</span></span><br><span class="line">     set_automatic_phase_objection(<span class="number">1</span>);</span><br><span class="line">    <span class="meta">`<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">task</span> body();</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// For UVM-1.1 &amp; UVM-1.2</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="meta">`<span class="meta-keyword">ifndef</span> UVM_VERSION</span></span><br><span class="line">      <span class="meta">`uvm_do_with(req, &#123;kind == DEASSERT; cycles == 2;&#125;);</span></span><br><span class="line">      <span class="meta">`uvm_do_with(req, &#123;kind == ASSERT; cycles == 1;&#125;);</span></span><br><span class="line">      <span class="meta">`uvm_do_with(req, &#123;kind == DEASSERT; cycles == 15;&#125;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// For IEEE UVM</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">`<span class="meta-keyword">else</span></span></span><br><span class="line">      <span class="meta">`uvm_do(req,,, &#123;kind == DEASSERT; cycles == 2;&#125;);</span></span><br><span class="line">      <span class="meta">`uvm_do(req,,, &#123;kind == ASSERT; cycles == 1;&#125;);</span></span><br><span class="line">      <span class="meta">`uvm_do(req,,, &#123;kind == DEASSERT; cycles == 15;&#125;);</span></span><br><span class="line">    <span class="meta">`<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">endtask</span>: body</span><br><span class="line"></span><br><span class="line">  <span class="meta">`<span class="meta-keyword">ifdef</span> UVM_VERSION_1_1</span></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">task</span> pre_start();</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line">    <span class="keyword">if</span> ((get_parent_sequence() == <span class="literal">null</span>) &amp;&amp; (starting_phase != <span class="literal">null</span>)) <span class="keyword">begin</span></span><br><span class="line">      starting_phase<span class="variable">.raise_objection</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">endtask</span>: pre_start</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">task</span> post_start();</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line">    <span class="keyword">if</span> ((get_parent_sequence() == <span class="literal">null</span>) &amp;&amp; (starting_phase != <span class="literal">null</span>)) <span class="keyword">begin</span></span><br><span class="line">      starting_phase<span class="variable">.drop_objection</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">endtask</span>: post_start</span><br><span class="line">  <span class="meta">`<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endclass</span>: reset_sequence</span><br></pre></td></tr></table></figure><p>在reset_trans中使用了assert和de-assert函数来初始化信号。文本中的介绍是这样的</p><blockquote><p>Within the reset transaction class, there is a control command field called kind.</p><p>If the kind field is ASSERT, then the driver will assert the reset signal for</p><p>the number of clock cycles are specified in the cycles field. Similar action</p><p>takes place for the DEASSERT command.</p></blockquote><p>然后提供了一个例子</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// For example, if the reset signal need to be asserted for 1 cycles then de-asserted</span></span><br><span class="line"><span class="comment">// for 15 clock cycles, the potential code might look like:</span></span><br><span class="line"></span><br><span class="line">reset_tr tr = reset_tr::type_id::create(<span class="string">&quot;tr&quot;</span>);</span><br><span class="line">tr<span class="variable">.randomize</span>() <span class="keyword">with</span> &#123;kind == ASSERT; cycles == <span class="number">1</span>;&#125;;</span><br><span class="line">tr<span class="variable">.randomize</span>() <span class="keyword">with</span> &#123;kind == DEASSERT; cycles == <span class="number">15</span>;;</span><br></pre></td></tr></table></figure><h4><span id="reset_agent">reset_agent</span></h4><p>在reset_agent中定义了三个类</p><h5><span id="reset_driver">reset_driver</span></h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> <span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">  <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">    seq_item_port<span class="variable">.get_next_item</span>(req);</span><br><span class="line">    drive(req);</span><br><span class="line">    seq_item_port<span class="variable">.item_done</span>();</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span>: run_phase</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> <span class="keyword">task</span> drive(reset_tr tr);</span><br><span class="line">  <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line">    <span class="keyword">if</span> (tr<span class="variable">.kind</span> == reset_tr::ASSERT) <span class="keyword">begin</span><span class="comment">//如果为激活状态，置0，否则置1</span></span><br><span class="line">    vif<span class="variable">.reset_n</span> = <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">repeat</span>(tr<span class="variable">.cycles</span>) @(vif<span class="variable">.mst</span>);<span class="comment">//mst是时钟</span></span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    vif<span class="variable">.reset_n</span> &lt;= &#x27;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">repeat</span>(tr<span class="variable">.cycles</span>) @(vif<span class="variable">.mst</span>);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span>: drive</span><br></pre></td></tr></table></figure><h5><span id="reset_monitor">reset_monitor</span></h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> reset_monitor <span class="keyword">extends</span> uvm_monitor;</span><br><span class="line">  <span class="keyword">virtual</span> reset_io vif;          <span class="comment">// DUT virtual interface</span></span><br><span class="line">  uvm_analysis_port <span class="variable">#(reset_tr)</span> analysis_port;</span><br><span class="line">    <span class="comment">//使用uvm_event来达成同步</span></span><br><span class="line">  uvm_event reset_event = uvm_event_pool::get_global(<span class="string">&quot;reset&quot;</span>);</span><br><span class="line">  <span class="meta">`uvm_component_utils(reset_monitor)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line">  <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line"></span><br><span class="line">    uvm_config_db<span class="variable">#(virtual reset_io)::get(this, &quot;&quot;, &quot;vif&quot;, vif)</span>;</span><br><span class="line">    analysis_port = <span class="keyword">new</span>(<span class="string">&quot;analysis_port&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">endfunction</span>: build_phase</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> end_of_elaboration_phase(uvm_phase phase);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.end_of_elaboration_phase</span>(phase);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line">    <span class="keyword">if</span> (vif == <span class="literal">null</span>) <span class="keyword">begin</span></span><br><span class="line">      <span class="meta">`uvm_fatal(&quot;CFGERR&quot;, &quot;Interface for reset monitor not set&quot;);</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">endfunction</span>: end_of_elaboration_phase</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">      reset_tr tr = reset_tr::type_id::create(<span class="string">&quot;tr&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">      detect(tr);</span><br><span class="line">      analysis_port<span class="variable">.write</span>(tr);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">endtask</span>: run_phase</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">task</span> detect(reset_tr tr);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line">    @(vif<span class="variable">.reset_n</span>);</span><br><span class="line">    <span class="keyword">assert</span>(!<span class="built_in">$isunknown</span>(vif<span class="variable">.reset_n</span>));</span><br><span class="line">    <span class="keyword">if</span> (vif<span class="variable">.reset_n</span> == <span class="number">1&#x27;b0</span>) <span class="keyword">begin</span></span><br><span class="line">      tr<span class="variable">.kind</span> = reset_tr::ASSERT;</span><br><span class="line">      reset_event<span class="variable">.trigger</span>();</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">      tr<span class="variable">.kind</span> = reset_tr::DEASSERT;</span><br><span class="line">      reset_event<span class="variable">.reset</span>(<span class="variable">.wakeup</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">endtask</span>: detect</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure><h5><span id="reset_agent">reset_agent</span></h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> reset_agent <span class="keyword">extends</span> uvm_agent;</span><br><span class="line">  <span class="keyword">typedef</span> uvm_sequencer<span class="variable">#(reset_tr)</span> reset_sequencer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> reset_io vif;          <span class="comment">// DUT virtual interface</span></span><br><span class="line">  reset_sequencer  sqr;</span><br><span class="line">  reset_driver     drv;</span><br><span class="line">  reset_monitor    mon;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">`uvm_component_utils(reset_agent)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line">  <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line">    <span class="meta">`uvm_info(&quot;RSTCFG&quot;, $sformatf(&quot;Reset agent %s setting for is_active is: %p&quot;, this.get_name(), is_active), UVM_MEDIUM);</span></span><br><span class="line"></span><br><span class="line">    uvm_config_db<span class="variable">#(virtual reset_io)::get(this, &quot;&quot;, &quot;vif&quot;, vif)</span>;</span><br><span class="line">    uvm_config_db<span class="variable">#(virtual reset_io)::set(this, &quot;*&quot;, &quot;vif&quot;, vif)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_active == UVM_ACTIVE) <span class="keyword">begin</span></span><br><span class="line">      sqr = reset_sequencer::type_id::create(<span class="string">&quot;sqr&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">      drv = reset_driver::type_id::create(<span class="string">&quot;drv&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    mon = reset_monitor::type_id::create(<span class="string">&quot;mon&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">endfunction</span>: build_phase</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> connect_phase(uvm_phase phase);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.connect_phase</span>(phase);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line">    <span class="keyword">if</span> (is_active == UVM_ACTIVE) <span class="keyword">begin</span></span><br><span class="line">      drv<span class="variable">.seq_item_port</span><span class="variable">.connect</span>(sqr<span class="variable">.seq_item_export</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">endfunction</span>: connect_phase</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> end_of_elaboration_phase(uvm_phase phase);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.end_of_elaboration_phase</span>(phase);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line">    <span class="keyword">if</span> (vif == <span class="literal">null</span>) <span class="keyword">begin</span></span><br><span class="line">      <span class="meta">`uvm_fatal(&quot;CFGERR&quot;, &quot;Interface for reset agent not set&quot;);</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">endfunction</span>: end_of_elaboration_phase</span><br><span class="line"></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure><p>这里面有一些不太懂的==uvm_event，analysis_port.write，还有一个is_active不知道是哪里来的，后面要查下用法==</p><p>（待补充）</p><p>__本文作者__：Yuchen <a href="http://example.com/2021/09/04/3/">http://example.com/2021/09/04/3/</a> <br>__版权声明__：转载请注明出处！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在lab3中，需要创建物理接口以及驱动。&lt;/p&gt;
&lt;h3&gt;&lt;span id=&quot;interface&quot;&gt;Interface&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span id=&quot;port_id&quot;&gt;port_id&lt;/span&gt;&lt;/h4&gt;&lt;figure class=&quot;highlight</summary>
      
    
    
    
    
    <category term="uvm" scheme="http://example.com/tags/uvm/"/>
    
  </entry>
  
  <entry>
    <title>UVM_LAB 2</title>
    <link href="http://example.com/2021/09/04/2/"/>
    <id>http://example.com/2021/09/04/2/</id>
    <published>2021-09-04T09:58:22.000Z</published>
    <updated>2021-09-04T11:22:53.862Z</updated>
    
    <content type="html"><![CDATA[<p>在第一个lab结束后，我们建立了一个最基本的UVM tb，但这个框架基本上完成不了其他的任务，因此，在第二个lab中，我们需要加入trans class和sequence class。</p><h3><span id="manage-class-files">Manage Class Files</span></h3><p>实验的第一步是通过打包来管理class files。在lab1中，我们将类文件放在test.sv中，这导致一旦有新的类文件加入就需要修改test文件，显然是不方便的。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> <span class="keyword">automatic</span> test;</span><br><span class="line"><span class="keyword">import</span> uvm_pkg::*;</span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> &quot;packet.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> &quot;driver.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> &quot;input_agent.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> &quot;router_env.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> &quot;test_collection.sv&quot;</span></span><br><span class="line"><span class="comment">//类文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  <span class="built_in">$timeformat</span>(-<span class="number">9</span>, <span class="number">1</span>, <span class="string">&quot;ns&quot;</span>, <span class="number">10</span>);</span><br><span class="line">  run_test();</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure><p>因此，考虑将类文件装在package中进行管理，lab2中使用了三个包，分别是router_env_pkg、router_stimulus_pkg、和router_test_pkg。</p><p>router_env_pkg</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> router_env_pkg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> uvm_pkg::*;</span><br><span class="line"><span class="keyword">import</span> router_stimulus_pkg::*;</span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> &quot;driver.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> &quot;input_agent.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> &quot;router_env.sv&quot;//管理driver、agent、env</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endpackage</span></span><br></pre></td></tr></table></figure><p>router_stimulus_pkg</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> router_stimulus_pkg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> uvm_pkg::*;</span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> &quot;packet.sv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> &quot;packet_sequence.sv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> &quot;packet_da_3.sv&quot;//管理trans相关的包</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endpackage</span></span><br></pre></td></tr></table></figure><p>router_test_pkg</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> router_test_pkg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> uvm_pkg::*;</span><br><span class="line"><span class="keyword">import</span> router_stimulus_pkg::*;</span><br><span class="line"><span class="keyword">import</span> router_env_pkg::*;</span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> &quot;test_collection.sv&quot;//包含上面两个包以及测试文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endpackage</span></span><br></pre></td></tr></table></figure><p>在使用包来管理类之后，test文件就只需要import两个包，方便很多</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> uvm_pkg::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> router_test_pkg::*;</span><br></pre></td></tr></table></figure><h3><span id="register-packet-class">Register Packet Class</span></h3><p>在packet文件中加入注册和build的部分</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// All transaction classes must be extended from the uvm_sequence_item base class.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> packet <span class="keyword">extends</span> uvm_sequence_item;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This class contain 4-bit sa (source address) and da (destination address) fields.</span></span><br><span class="line">  <span class="comment">// The payload field is a queue of 8-bit variable.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] sa, da;</span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span>[<span class="number">7</span>:<span class="number">0</span>] payload[$];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register the class into the UVM factory and enable the fields</span></span><br><span class="line">  <span class="meta">`uvm_object_utils_begin(packet)</span></span><br><span class="line">    <span class="meta">`uvm_field_int(sa, UVM_ALL_ON | UVM_NOCOMPARE)</span></span><br><span class="line">    <span class="meta">`uvm_field_int(da, UVM_ALL_ON)</span></span><br><span class="line">    <span class="meta">`uvm_field_queue_int(payload, UVM_ALL_ON)</span></span><br><span class="line">  <span class="meta">`uvm_object_utils_end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// To make viewing the success of the labs a little easier, the payload size is</span></span><br><span class="line">  <span class="comment">// restricted to 1 to 10 bytes.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constraint</span> valid &#123;</span><br><span class="line">    payload<span class="variable">.size</span> <span class="keyword">inside</span> &#123;[<span class="number">1</span>:<span class="number">10</span>]&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Since this is not a component class, there can only be one argument in the</span></span><br><span class="line">  <span class="comment">// constructor signature.  This string argument must be defaulted to the class name.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;packet&quot;</span>);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line">  <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endclass</span>: packet</span><br></pre></td></tr></table></figure><p>另外注意到，由于trans类不是uvm_component，没有办法调用build_phase，因此在例化的时候需要使用new函数。</p><h3><span id="execute-tests-with-override">Execute tests with override</span></h3><p>可以看到，在定义了packet这个类之后，我们就能自由的产生我们需要的数据了，lab2中生成了一个接收地址为3的packet：packet_da_3。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> packet_da_3 <span class="keyword">extends</span> packet;</span><br><span class="line">  <span class="meta">`uvm_object_utils(packet_da_3)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constraint</span> da_3 &#123;</span><br><span class="line">    da == <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;packet_da_3&quot;</span>);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name);</span><br><span class="line">   <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line">  <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"><span class="keyword">endclass</span>: packet_da_3</span><br></pre></td></tr></table></figure><p>在这个包中，通过限定constraint函数的约束条件，使得da等于三。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在第一个lab结束后，我们建立了一个最基本的UVM tb，但这个框架基本上完成不了其他的任务，因此，在第二个lab中，我们需要加入trans class和sequence class。&lt;/p&gt;
&lt;h3&gt;&lt;span id=&quot;manage-class-files&quot;&gt;Manage</summary>
      
    
    
    
    
    <category term="uvm" scheme="http://example.com/tags/uvm/"/>
    
  </entry>
  
  <entry>
    <title>UVM</title>
    <link href="http://example.com/2021/09/03/UVM/"/>
    <id>http://example.com/2021/09/03/UVM/</id>
    <published>2021-09-03T15:16:04.000Z</published>
    <updated>2021-09-03T15:16:43.695Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="认识uvm的结构">认识UVM的结构</span></h1><blockquote><p>本文学习资料引用自<a href="https://colorlesscube.com/uvm-guide-for-beginners/chapter-2-defining-the-verification-environment/">https://colorlesscube.com/uvm-guide-for-beginners/chapter-2-defining-the-verification-environment/</a></p></blockquote><h2><span id="一-dut介绍">一、DUT介绍</span></h2><p>DUT是一个简单的加法器，时序图和状态机见图。具体作用是两个通道ina和inb，将他们相加再通过out输出，输入的信号采样到en_i,输出的信号采样到en_o。</p><p><img src="https://img-blog.csdnimg.cn/20210829234407908.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFyb2xkIEZleQ==,size_15,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><img src="http://colorlesscube.com/wp-content/uploads/ch2-dut_state_machine.png" alt="DUT State Machine" style="zoom:50%;"><img src="http://colorlesscube.com/wp-content/uploads/ch2-dut_timing_diagram.png" alt="DUT Timing Diagram" style="zoom:50%;"><h2><span id="二-验证环境">二、验证环境</span></h2><p><img src="http://colorlesscube.com/wp-content/uploads/ch3-uvm_tb_typical.png" alt="Typical UVM testbench"></p><h2><span id="三-top-block">三、Top block!</span></h2><p>在正常的开发中，DUT的开发是与TB的开发分开的，因此会有两个部分来连接他们，包括</p><ol><li>TB的顶层模块（Top block ）</li><li>虚拟接口（virtual interface）</li></ol><p>顶层模块例化DUT和TB，而接口则负责连接他们。</p><p>一个典型的接口如下,可以看到接口部分只例化了名称，但没有标明具体的输入输出。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> simpleadder_if;</span><br><span class="line">     <span class="keyword">logic</span>    sig_clock;</span><br><span class="line">     <span class="keyword">logic</span>    sig_ina;</span><br><span class="line">     <span class="keyword">logic</span>    sig_inb;</span><br><span class="line">     <span class="keyword">logic</span>    sig_en_i;</span><br><span class="line">     <span class="keyword">logic</span>    sig_out;</span><br><span class="line">     <span class="keyword">logic</span>    sig_en_o;</span><br><span class="line"><span class="keyword">endinterface</span>: simpleadder_if</span><br></pre></td></tr></table></figure><p>顶层模块的任务包括：</p><ol><li><p>将DUT连接到测试文件</p></li><li><p>生成DUT测试需要的时钟</p></li><li><p>将interface在UVM factory中注册</p></li><li><p>运行测试</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">include</span> &quot;simpleadder_pkg.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> &quot;simpleadder.v&quot;</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> &quot;simpleadder_if.sv&quot;//引用所需要的包文件、头文件以及接口文件</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">module</span> simpleadder_tb_top;</span><br><span class="line">     <span class="keyword">import</span> uvm_pkg::*;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//Interface declaration 例化接口</span></span><br><span class="line">     simpleadder_if vif();</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//Connects the Interface to the DUT 将接口与DUT连接</span></span><br><span class="line">     simpleadder dut(vif<span class="variable">.sig_clock</span>,</span><br><span class="line">                     vif<span class="variable">.sig_en_i</span>,</span><br><span class="line">                     vif<span class="variable">.sig_ina</span>,</span><br><span class="line">                     vif<span class="variable">.sig_inb</span>,</span><br><span class="line">                     vif<span class="variable">.sig_en_o</span>,</span><br><span class="line">                     vif<span class="variable">.sig_out</span>);</span><br><span class="line">     <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">          <span class="comment">//Registers the Interface in the configuration block</span></span><br><span class="line">          <span class="comment">//so that other blocks can use it 注册</span></span><br><span class="line">          uvm_resource_db<span class="variable">#(virtual simpleadder_if)::set(.scope(&quot;ifs&quot;), .name(&quot;simpleadder_if&quot;), .val(vif))</span>;</span><br><span class="line"> </span><br><span class="line">          <span class="comment">//Executes the test</span></span><br><span class="line">          run_test();</span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">     <span class="comment">//Variable initialization</span></span><br><span class="line">     <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">          vif<span class="variable">.sig_clock</span> = <span class="number">1&#x27;b1</span>;</span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">     <span class="comment">//Clock generation</span></span><br><span class="line">     <span class="keyword">always</span></span><br><span class="line">          #<span class="number">5</span> vif<span class="variable">.sig_clock</span> = ~vif<span class="variable">.sig_clock</span>;</span><br><span class="line">     <span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2><span id="四-sequences-and-sequencers">四、Sequences and sequencers</span></h2><p>验证DUT的功能时，需要产生一连串的数据。这就产生了transaction这个类。</p><h3><span id="transaction">transaction</span></h3><p>transaction是一个由<em>uvm_transaction</em> 或者<em>uvm_sequence_item</em>延伸出的类，其中包含了需要传给DUT的数据。</p><p>transaction是验证结构中所使用的最小的数据单位，包括数据类型、变量和方法，优秀的设计可以让transaction多次复用。</p><p>在有了基本的数据包之后，验证环境将需要生成它们的集合并准备好将它们发送给驱动程序。这是序列（sequence）的工作。sequence相当于一个弹夹，其延伸于 <em>uvm_sequence</em>，将trans形成有序集合发送给sequencer，而sequencer的任务是将sequence形成的数据包发送给driver。</p><p><img src="https://colorlesscube.com/wp-content/uploads/ch5-uvm_tb_sequence.png" alt="img"></p><p>一个简单的trans如下</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> simpleadder_transaction <span class="keyword">extends</span> uvm_sequence_item;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span>[<span class="number">1</span>:<span class="number">0</span>] ina;<span class="comment">//随机化输入的a、b数据</span></span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span>[<span class="number">1</span>:<span class="number">0</span>] inb;<span class="comment">//</span></span><br><span class="line">     <span class="keyword">bit</span>[<span class="number">2</span>:<span class="number">0</span>] out;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;&quot;</span>);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.new</span>(name);</span><br><span class="line">     <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">`uvm_object_utils_begin(simpleadder_transaction)//注册</span></span><br><span class="line">    <span class="meta">`uvm_field_int(ina, UVM_ALL_ON)//使用uvm_field宏进行注册</span></span><br><span class="line">     <span class="meta">`uvm_field_int(inb, UVM_ALL_ON)</span></span><br><span class="line">     <span class="meta">`uvm_field_int(out, UVM_ALL_ON)</span></span><br><span class="line">     <span class="meta">`uvm_object_utils_end</span></span><br><span class="line"><span class="keyword">endclass</span>: simpleadder_transaction</span><br></pre></td></tr></table></figure><p>关于uvm_field</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">define</span> uvm_field_int(ARG,FLAG)</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">define</span> uvm_field_real(ARG,FLAG)</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">define</span> uvm_field_enum(T,ARG,FLAG)</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">define</span> uvm_field_object(ARG,FLAG)</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">define</span> uvm_field_event(ARG,FLAG)</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">define</span> uvm_field_string(ARG,FLAG)</span></span><br><span class="line">上述几个宏分别用于要注册的字段是整数、实数、枚举类型、直接或间接派生自uvm_object的类型、事件及字符串类型。这里除了枚举类型外，都是两个参数。对于枚举类型来说，需要有三个参数。假如有枚举类型tb_bool_e，同时有变量tb_flag，那么在使用field automation机制时应该使用如下方式实现：</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;TB_TRUE, TB_FALSE&#125; tb_bool_e;</span><br><span class="line">…</span><br><span class="line">tb_bool_e tb_flag;</span><br><span class="line">…</span><br><span class="line"><span class="meta">`uvm_field_enum(tb_bool_e, tb_flag, UVM_ALL_ON)</span></span><br></pre></td></tr></table></figure><p>而使用trans的好处在于，如果我们需要在测试一个三接口的dut，我们无需重写，只要从原来的trans里拓展出一个新trans就可以，如下</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> simpleadder_transaction_3inputs <span class="keyword">extends</span> simpleadder_transaction;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span>[<span class="number">1</span>:<span class="number">0</span>] inc;<span class="comment">//添加新接口inc</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;&quot;</span>);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.new</span>(name);</span><br><span class="line">     <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"> </span><br><span class="line">     <span class="meta">`uvm_object_utils_begin(simpleadder_transaction_3inputs)</span></span><br><span class="line">    <span class="meta">`uvm_field_int(inc, UVM_ALL_ON)//注册新接口inc</span></span><br><span class="line">     <span class="meta">`uvm_object_utils_end</span></span><br><span class="line"><span class="keyword">endclass</span>: simpleadder_transaction_3inputs</span><br></pre></td></tr></table></figure><h3><span id="sequence">Sequence</span></h3><p>创建了trans之后，就可以写一个由trans组成的sequence</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> simpleadder_sequence <span class="keyword">extends</span> uvm_sequence<span class="variable">#(simpleadder_transaction)</span>;<span class="comment">//创建新类，调用之前设置好的trans</span></span><br><span class="line">     <span class="meta">`uvm_object_utils(simpleadder_sequence)</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;&quot;</span>);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.new</span>(name);</span><br><span class="line">     <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">task</span> body();</span><br><span class="line">          simpleadder_transaction sa_tx;</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">repeat</span>(<span class="number">15</span>) <span class="keyword">begin</span><span class="comment">//产生15个trans</span></span><br><span class="line">             sa_tx = simpleadder_transaction::type_id::create(...<span class="comment">//使用create函数产生空白trans</span></span><br><span class="line"> </span><br><span class="line">               start_item(sa_tx);</span><br><span class="line">                    <span class="keyword">assert</span>(sa_tx<span class="variable">.randomize</span>());</span><br><span class="line">               finish_item(sa_tx);</span><br><span class="line">         <span class="keyword">end</span><span class="comment">//随机化，start()和finish()函数分别是阻塞函数</span></span><br><span class="line">     <span class="keyword">endtask</span>: body</span><br><span class="line"><span class="keyword">endclass</span>: simpleadder_sequence</span><br></pre></td></tr></table></figure><h3><span id="sequencer">Sequencer</span></h3><p>而sequencer则只需要一行很短的代码</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> uvm_sequencer<span class="variable">#(simpleadder_transaction)</span> simpleadder_sequencer;</span><br></pre></td></tr></table></figure><p>这告诉UVM系统，只需要使用默认参数创建一个sequencer。</p><p>至此，我们构建出了DUT、Interface、Sequencer</p><p><img src="http://colorlesscube.com/wp-content/uploads/ch5-uvm_tb_simpleadder_sequencer.png" alt="State of the verification environment after the sequencer"></p><p>但是仍有两个问题没有解决：</p><ol><li>sequence如何连接到sequencer</li><li>sequencer如何连接到driver</li></ol><h2><span id="五-driver">五、Driver</span></h2><p>Driver是一个与Dut交互的元件，可以从上图看到driver从Sequencer中接受trans，在通过interface发送给dut。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> simpleadder_driver <span class="keyword">extends</span> uvm_driver<span class="variable">#(simpleadder_transaction)</span>;</span><br><span class="line">    <span class="comment">//The #(simpleadder_transaction) is a SystemVerilog parameter</span></span><br><span class="line">    <span class="comment">//it represents the data type that it will be retrieved from the sequencer.</span></span><br><span class="line">    </span><br><span class="line">     <span class="meta">`uvm_component_utils(simpleadder_driver)</span></span><br><span class="line"> </span><br><span class="line">     <span class="comment">//Interface declaration</span></span><br><span class="line">     <span class="keyword">protected</span> <span class="keyword">virtual</span> simpleadder_if vif;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">     <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">     <span class="keyword">void</span>&#x27;(uvm_resource_db<span class="variable">#(virtual simpleadder_if)::read_by_name(.scope(&quot;ifs&quot;), .name(&quot;simpleadder_if&quot;), .val(vif)))</span>;<span class="comment">//gets the interface from the factory database</span></span><br><span class="line">     <span class="keyword">endfunction</span>: build_phase</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">          <span class="comment">//Our code here</span></span><br><span class="line">     <span class="keyword">endtask</span>: run_phase</span><br><span class="line"><span class="keyword">endclass</span>: simpleadder_driver</span><br></pre></td></tr></table></figure><p>run_phase()的任务就是根据前面的状态机写代码</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> <span class="keyword">task</span> drive();</span><br><span class="line">    simpleadder_transaction sa_tx;</span><br><span class="line">    <span class="keyword">integer</span> counter = <span class="number">0</span>, state = <span class="number">0</span>;</span><br><span class="line">    vif<span class="variable">.sig_ina</span> = <span class="number">0&#x27;b0</span>;</span><br><span class="line">    vif<span class="variable">.sig_inb</span> = <span class="number">0&#x27;b0</span>;</span><br><span class="line">    vif<span class="variable">.sig_en_i</span> = <span class="number">1&#x27;b0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(counter==<span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">//Gets a transaction from the sequencer and</span></span><br><span class="line">            <span class="comment">//stores it in the variable &#x27;sa_tx&#x27;</span></span><br><span class="line">            seq_item_port<span class="variable">.get_next_item</span>(sa_tx);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">        @(<span class="keyword">posedge</span> vif<span class="variable">.sig_clock</span>)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(counter==<span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">                vif<span class="variable">.sig_en_i</span> = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                state = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span>(counter==<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                vif<span class="variable">.sig_en_i</span> = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span>   </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">case</span>(state)</span><br><span class="line">                <span class="number">1</span>: <span class="keyword">begin</span></span><br><span class="line">                    vif<span class="variable">.sig_ina</span> = sa_tx<span class="variable">.ina</span>[<span class="number">1</span>];</span><br><span class="line">                    vif<span class="variable">.sig_inb</span> = sa_tx<span class="variable">.inb</span>[<span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line">                    sa_tx<span class="variable">.ina</span> = sa_tx<span class="variable">.ina</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                    sa_tx<span class="variable">.inb</span> = sa_tx<span class="variable">.inb</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">                    counter = counter + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(counter==<span class="number">2</span>) state = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">                <span class="number">2</span>: <span class="keyword">begin</span></span><br><span class="line">                    vif<span class="variable">.sig_ina</span> = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    vif<span class="variable">.sig_inb</span> = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    counter = counter + <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">if</span>(counter==<span class="number">6</span>) <span class="keyword">begin</span></span><br><span class="line">                        counter = <span class="number">0</span>;</span><br><span class="line">                        state = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">                        <span class="comment">//Informs the sequencer that the</span></span><br><span class="line">                        <span class="comment">//current operation with</span></span><br><span class="line">                        <span class="comment">//the transaction was finished</span></span><br><span class="line">                        seq_item_port<span class="variable">.item_done</span>();</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span>: drive</span><br></pre></td></tr></table></figure><p>关于virtual这个关键词可以展开说一下，不好排版，放在后面吧</p><p>==关于uvm_resource_db这个机制，可以参考<a href="http://www.dvagent.com/forum.php?mod=viewthread&amp;tid=269%EF%BC%8C%E7%AD%89%E6%9C%89%E7%A9%BA%E4%BA%86%E6%88%91%E5%86%8D%E6%9D%A5%E6%95%B4%E7%90%86==">http://www.dvagent.com/forum.php?mod=viewthread&amp;tid=269，等有空了我再来整理==</a></p><h3><span id="virtual">virtual</span></h3><ol><li><h5><span id="virtual-interface">virtual interface</span></h5><ul><li>在interface定义时，如果不使用关键字 “virtual” 那么==在多次调用该接口时，在其中的一个实例中对接口中某一信号的修改会影响其他实例接口==；如果使用了 “virtual” 关键字，那么每个实例是独立的。</li><li>习惯上在声明interface时均添加 “virtual”关键字。</li></ul></li><li><h5><span id="virtual-taskfunction">virtual task/function</span></h5><ul><li><p>用于OOP思想的继承使用。当定义了virtual时，==在子类中调用某task/function时，会先查找在子类中是否定义了该 task/function，如果子类没有定义，则在父类中查找。==未定义virtual时，只在子类中查找，没有定义就是编译器报错。</p></li><li><p>如果某一class会被继承，则用户定义的task/function（除new()，randomized()，per_randomize()，pose_randomize()外），都应该加上virtual关键字，以备后续扩展。</p></li></ul></li><li><h5><span id="virtual-class">virtual class</span></h5><ul><li><p>虚类一般用来定义类的格式,、类的成员、类的参数等，==虚类不能被实例化==，只能被扩展（重载）后实例化，用于在项目中定义一些标准的类。</p></li><li><p>虚类中的方法通常使用关键字 “ pure virtual “ 纯虚方法。同时OOP规定，只要class中存在一个没有被实现的pure function，就不允许例化这个class。</p></li></ul></li></ol><h3><span id="local-protected-static">local、protected、static</span></h3><ol><li>公有与私有<ul><li>在SV中，所有成员默认都是 public 类型的，除非显示的使用关键字 <strong>local/protected</strong> 来声明。local与protected均可对方法或者属性进行修饰说明。</li><li>local 表示的成员或方法只对该类的对象可见，扩展类以及类外不可见；</li><li>protected 表示的成员或方法对该类==以及扩展类可见==，对类外不可见；</li></ul></li><li>静态与全局</li></ol><h5><span id="静态属性">静态属性</span></h5><p>对于普通的实例类属性，每一个类实例的每一个变量都有自己的copy（单独的内存空间），相互独立。但是有时会要求一个类的所有实例都共享变量的一个版本，也就是说所有实例都共享同一个copy，该变量对所有实例都是可见并相同的。</p><p>这样的类属性就是静态属性（静态变量），使用关键字<strong>static</strong>产生。通过下面的例子可以清楚的看见静态属性的特点。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line">  <span class="keyword">bit</span> [<span class="number">15</span>:<span class="number">0</span>]   addr;</span><br><span class="line">  <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>]   data;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span>   static_ctr = <span class="number">0</span>;<span class="comment">//static</span></span><br><span class="line">       <span class="keyword">int</span>   ctr = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span> (<span class="keyword">bit</span> [<span class="number">15</span>:<span class="number">0</span>] ad, <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] d);</span><br><span class="line">    addr = ad;</span><br><span class="line">    data = d;</span><br><span class="line">    static_ctr++;</span><br><span class="line">    ctr++;</span><br><span class="line">    <span class="built_in">$display</span> (<span class="string">&quot;static_ctr=%0d ctr=%0d addr=0x%0h data=0x%0h&quot;</span>, static_ctr, ctr, addr, data);</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    Packet   p1, p2, p3;</span><br><span class="line">    p1 = <span class="keyword">new</span> (<span class="number">16&#x27;hdead</span>, <span class="number">8&#x27;h12</span>);</span><br><span class="line">    p2 = <span class="keyword">new</span> (<span class="number">16&#x27;hface</span>, <span class="number">8&#x27;hab</span>);</span><br><span class="line">    p3 = <span class="keyword">new</span> (<span class="number">16&#x27;hcafe</span>, <span class="number">8&#x27;hfc</span>);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ncsim&gt; run</span><br><span class="line">static_ctr=<span class="number">1</span> ctr=<span class="number">1</span> addr=<span class="number">0</span>xdead data=<span class="number">0</span>x12<span class="comment">//可以看到ctr只在单次的new中产生</span></span><br><span class="line">static_ctr=<span class="number">2</span> ctr=<span class="number">1</span> addr=<span class="number">0</span>xface data=<span class="number">0</span>xab<span class="comment">//而static_ctr则始终在计数</span></span><br><span class="line">static_ctr=<span class="number">3</span> ctr=<span class="number">1</span> addr=<span class="number">0</span>xcafe data=<span class="number">0</span>xfc</span><br><span class="line">ncsim: *W,RNQUIE: Simulation is complete.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>静态属性还有一个重要的特点是<strong>其类无需实例化，就可直接使用静态属性</strong>。需要利用范围操作符::</p><p>一个静态方法遵守所有的类范围和访问规则，**但是它可以在类的外部被调用，即使没有该类的实例。外部调用的方法同样需要使用范围操作符::**。</p><h5><span id="静态方法">静态方法</span></h5><p>一个静态方法不能访问非静态的属性或方法，但是可以直接访问静态属性，或者调用同一个类中的静态方法，原因很简单因为静态属性和静态方法可以在类没有实例化时被调用，具有全局的静态生命周期，而普通的非静态成员无法做到这点。<br>在一个静态方法内部访问非静态成员或者使用this句柄都是非法的。<br>静态方法不能是虚拟的。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> ctr=<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">function</span> <span class="keyword">new</span> ();</span><br><span class="line">      ctr++;</span><br><span class="line">   <span class="keyword">endfunction</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">function</span> get_pkt_ctr ();</span><br><span class="line">    <span class="built_in">$display</span> (<span class="string">&quot;ctr=%0d&quot;</span>, ctr);</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">  Packet pkt [<span class="number">6</span>];</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">$size</span>(pkt); i++) <span class="keyword">begin</span></span><br><span class="line">      pkt[i] = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    Packet::get_pkt_ctr();   <span class="comment">// Static call using :: operator</span></span><br><span class="line">    pkt[<span class="number">5</span>]<span class="variable">.get_pkt_ctr</span>();   <span class="comment">// Normal call using instance</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ncsim&gt; run</span><br><span class="line">ctr=<span class="number">6</span></span><br><span class="line">ctr=<span class="number">6</span></span><br><span class="line">ncsim: *W,RNQUIE: Simulation is complete.</span><br></pre></td></tr></table></figure><p>可以看到，通过域操作符和使用实例中的函数，得到的结果是相同的，并且pkt[]的6个成员的调用结果都会是一样的（操作对象是只有一个copy的静态属性）。</p><h2><span id="六-monitor">六、Monitor</span></h2><p>监视器是一个无源元件，它不会将任何信号驱动到 DUT 中，其目的是提取信号信息并将其转换为有意义的信息以供其他元件评估。</p><p>监测器应包括：</p><ul><li><p>遵守协议的 DUT 输出</p></li><li><p>用于功能覆盖分析的 DUT 输入</p></li></ul><p>在本例中，我们创建两个monitor，对两个输入进行采样，对预期结果进行预测并将其与 DUT 的结果进行比较：</p><ul><li><p>第一个监视器 monitor_before 将只查找设备的输出并将结果传递给记分板。</p></li><li><p>第二个监视器 monitor_after 将获得两个输入并对预期结果进行预测。记分板也会得到这个预测结果，并对两个值进行比较。</p></li></ul><p>monitor_before</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> simpleadder_monitor_before <span class="keyword">extends</span> uvm_monitor;</span><br><span class="line">     <span class="meta">`uvm_component_utils(simpleadder_monitor_before)</span></span><br><span class="line"> </span><br><span class="line">    uvm_analysis_port<span class="variable">#(simpleadder_transaction)</span> mon_ap_before;<span class="comment">//</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">virtual</span> simpleadder_if vif;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">     <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line"> </span><br><span class="line">          <span class="keyword">void</span>&#x27;(uvm_resource_db<span class="variable">#(virtual simpleadder_if)::read_by_name (.scope(&quot;ifs&quot;), .name(&quot;simpleadder_if&quot;), .val(vif)))</span>;</span><br><span class="line">          mon_ap_before = <span class="keyword">new</span>(<span class="variable">.name</span>(<span class="string">&quot;mon_ap_before&quot;</span>), <span class="variable">.parent</span>(<span class="keyword">this</span>));</span><br><span class="line">     <span class="keyword">endfunction</span>: build_phase</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">          <span class="comment">//Our code here</span></span><br><span class="line">     <span class="keyword">endtask</span>: run_phase</span><br><span class="line"><span class="keyword">endclass</span>: simpleadder_monitor_before</span><br></pre></td></tr></table></figure><p>monitor_after</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> simpleadder_monitor_after <span class="keyword">extends</span> uvm_monitor;</span><br><span class="line">     <span class="meta">`uvm_component_utils(simpleadder_monitor_after)</span></span><br><span class="line"> </span><br><span class="line">     uvm_analysis_port<span class="variable">#(simpleadder_transaction)</span> mon_ap_after;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">virtual</span> simpleadder_if vif;</span><br><span class="line"> </span><br><span class="line">     simpleadder_transaction sa_tx_cg;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">covergroup</span> simpleadder_cg;</span><br><span class="line">          ina_cp:     <span class="keyword">coverpoint</span> sa_tx_cg<span class="variable">.ina</span>;</span><br><span class="line">          inb_cp:     <span class="keyword">coverpoint</span> sa_tx_cg<span class="variable">.inb</span>;</span><br><span class="line">          <span class="keyword">cross</span> ina_cp, inb_cp;</span><br><span class="line">     <span class="keyword">endgroup</span>: simpleadder_cg</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">          simpleadder_cg = <span class="keyword">new</span>;</span><br><span class="line">     <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line"> </span><br><span class="line">          <span class="keyword">void</span>&#x27;(uvm_resource_db<span class="variable">#(virtual simpleadder_if)::read_by_name(.scope(&quot;ifs&quot;), .name(&quot;simpleadder_if&quot;), .val(vif)))</span>;</span><br><span class="line">          mon_ap_after= <span class="keyword">new</span>(<span class="variable">.name</span>(<span class="string">&quot;mon_ap_after&quot;</span>), <span class="variable">.parent</span>(<span class="keyword">this</span>));</span><br><span class="line">     <span class="keyword">endfunction</span>: build_phase</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">          <span class="comment">//Our code here</span></span><br><span class="line">     <span class="keyword">endtask</span>: run_phase</span><br><span class="line"><span class="keyword">endclass</span>: simpleadder_monitor_after</span><br></pre></td></tr></table></figure><h4><span id="tlm-端口">TLM 端口</span></h4><p>在讨论trans时，我们忽略了一个问题，就是其如何在各个元件中间流通，答案是通过端口。</p><p>TLM 代表事务级建模（Transaction Level Modeling），它是一种对数字系统之间的通信进行建模的高级方法。这种方法主要体现在两个方面：端口和出口。</p><p><img src="http://colorlesscube.com/wp-content/uploads/ch7-uvm_port_export.png" alt="Port-export communication"></p><p>如上所示，consumer实现一个函数，该函数使用一个trans作为参数，而producer调用该函数，同时将作为参数的trans传递给consumer。top_class将这两个元件组合在一起。</p><p>一个例子如下图</p><img src="http://colorlesscube.com/wp-content/uploads/ch7-uvm_port_export_sample_code.jpeg" alt="Sample code for ports and exports" style="zoom:80%;"><p>这张图中，top_class使用connect方法将consumer的端口连接到了productor的端口上</p><p><img src="http://colorlesscube.com/wp-content/uploads/ch7-uvm_port_export_sumup.png" alt="Sum up of TLM-1.0 ports"></p><p>而在port和export是一一对应的关系，而在需要一对多的时候，可以使用analysis port。</p><p><img src="http://colorlesscube.com/wp-content/uploads/ch7-uvm_analysis_port_export.png" alt="Analysis port communication"></p><h2><span id="七-agent">七、Agent</span></h2><p>在有了sequencer、driver 、monitor之后，下一步的任务是将它们链接起来，这一步由agent来完成。</p><p>agent中没有run_phase，一个connect_phase取代了它。</p><p>我们将在构建阶段构建monitor、sequencer、driver。我们还需要创建两个分析端口，这些端口将充当监视器的代理，以便通过代理端口连接到外部scoreboard。</p><p><img src="http://colorlesscube.com/wp-content/uploads/ch8-uvm_tb_simpleadder_agent.png" alt="State of the testbench after the agent"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> simpleadder_agent <span class="keyword">extends</span> uvm_agent;</span><br><span class="line">     <span class="meta">`uvm_component_utils(simpleadder_agent)</span></span><br><span class="line"> </span><br><span class="line">     <span class="comment">//Analysis ports to connect the monitors to the scoreboard</span></span><br><span class="line">     uvm_analysis_port<span class="variable">#(simpleadder_transaction)</span> agent_ap_before;</span><br><span class="line">     uvm_analysis_port<span class="variable">#(simpleadder_transaction)</span> agent_ap_after;</span><br><span class="line"> </span><br><span class="line">     simpleadder_sequencer        sa_seqr;</span><br><span class="line">     simpleadder_driver        sa_drvr;</span><br><span class="line">     simpleadder_monitor_before    sa_mon_before;</span><br><span class="line">     simpleadder_monitor_after    sa_mon_after;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">     <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line"> </span><br><span class="line">          agent_ap_before    = <span class="keyword">new</span>(<span class="variable">.name</span>(<span class="string">&quot;agent_ap_before&quot;</span>), <span class="variable">.parent</span>(<span class="keyword">this</span>));</span><br><span class="line">          agent_ap_after    = <span class="keyword">new</span>(<span class="variable">.name</span>(<span class="string">&quot;agent_ap_after&quot;</span>), <span class="variable">.parent</span>(<span class="keyword">this</span>));</span><br><span class="line"> </span><br><span class="line">          sa_seqr        = simpleadder_sequencer::type_id::create(...</span><br><span class="line">          sa_drvr        = simpleadder_driver::type_id::create(...</span><br><span class="line">          sa_mon_before    = simpleadder_monitor_before::type_id::create(...</span><br><span class="line">          sa_mon_after    = simpleadder_monitor_after::type_id::create(...</span><br><span class="line">     <span class="keyword">endfunction</span>: build_phase</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">void</span> connect_phase(uvm_phase phase);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.connect_phase</span>(phase);</span><br><span class="line">          sa_drvr<span class="variable">.seq_item_port</span><span class="variable">.connect</span>(sa_seqr<span class="variable">.seq_item_export</span>);</span><br><span class="line">          sa_mon_before<span class="variable">.mon_ap_before</span><span class="variable">.connect</span>(agent_ap_before);</span><br><span class="line">          sa_mon_after<span class="variable">.mon_ap_after</span><span class="variable">.connect</span>(agent_ap_after);</span><br><span class="line">     <span class="keyword">endfunction</span>: connect_phase</span><br><span class="line"><span class="keyword">endclass</span>: simpleadder_agent</span><br></pre></td></tr></table></figure><p>关于uvm_resource_db这个指令，有一个简单的例子，具体的应用应该还要再查书。</p><blockquote><p>以下将创建一个新资源，填充它并将其插入到资源池中。</p><p>uvm_resource_db#（int）::set(“roman”,”top.aa..*”,2011,this);</p><p>我们创建了一个名为“roman”的新资源，在“top.aa..*”标识的范围内可见，值为2011。</p><p>检索此资源的组件将从数据库中读取值。</p><p>if(!uvm_resource_db#（int）::read_by_name(“roman”,get_full_name(),value,this))</p><p>`uvm_error(“WRONG”,”在此范围内未找到资源”);</p><p>read_by_name() 返回一个指示查找是否成功的位。</p><p>uvm_resource_db#（T）类是底层数据库访问类和方法之上的一个便利层。它没有被实例化。但包含一组操作资源和资源池的静态函数。</p><p><a href="https://forums.accellera.org/topic/305-uvm_resource_db-class-usage/">https://forums.accellera.org/topic/305-uvm_resource_db-class-usage/</a></p></blockquote><h2><span id="八-scoreboard">八、Scoreboard</span></h2><p>scoreboard是关键一环，用于检测dut的功能是否正确，其编写是最重要的。</p><p>在agent中，我们创建了两个监视器，因此，我们必须在记分板中创建两个analysis port，用于从两个监视器检索交易。之后，将在运行阶段执行一个方法 compare() 并比较两个事务。如果它们匹配，则意味着测试平台和 DUT 在功能上都一致，它将返回“OK”消息。</p><p>但是我们有一个问题：我们有来自两个监视器的两个事务流，我们需要确保它们是同步的。这可以通过编写适当的 write() 函数来手动完成，但有一种更简单、更清晰的方法：使用 UVM FIFO。==这个fifo要再去查一下==</p><p><img src="http://colorlesscube.com/wp-content/uploads/ch9-uvm_tb_fifo.png" alt="Usage of FIFO in the scoreboard"></p><p>FIFO 的实例化类似于端口/导出，使用 uvm_tlm_analysis_fifo #(generic_transaction) generic_fifo 并且它们已经实现了从监视器调用的相应 write() 函数。要访问它们的数据，我们只需从每个 FIFO 执行 get() 方法。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> simpleadder_scoreboard <span class="keyword">extends</span> uvm_scoreboard;</span><br><span class="line">     <span class="meta">`uvm_component_utils(simpleadder_scoreboard)</span></span><br><span class="line"> </span><br><span class="line">     uvm_analysis_export <span class="variable">#(simpleadder_transaction)</span> sb_export_before;</span><br><span class="line">     uvm_analysis_export <span class="variable">#(simpleadder_transaction)</span> sb_export_after;</span><br><span class="line"> </span><br><span class="line">     uvm_tlm_analysis_fifo <span class="variable">#(simpleadder_transaction)</span> before_fifo;</span><br><span class="line">     uvm_tlm_analysis_fifo <span class="variable">#(simpleadder_transaction)</span> after_fifo;</span><br><span class="line"> </span><br><span class="line">     simpleadder_transaction transaction_before;</span><br><span class="line">     simpleadder_transaction transaction_after;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">          transaction_before    = <span class="keyword">new</span>(<span class="string">&quot;transaction_before&quot;</span>);</span><br><span class="line">          transaction_after    = <span class="keyword">new</span>(<span class="string">&quot;transaction_after&quot;</span>);</span><br><span class="line">     <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">          sb_export_before    = <span class="keyword">new</span>(<span class="string">&quot;sb_export_before&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">          sb_export_after        = <span class="keyword">new</span>(<span class="string">&quot;sb_export_after&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"> </span><br><span class="line">          before_fifo        = <span class="keyword">new</span>(<span class="string">&quot;before_fifo&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">          after_fifo        = <span class="keyword">new</span>(<span class="string">&quot;after_fifo&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">     <span class="keyword">endfunction</span>: build_phase<span class="comment">//build_phase和注册到底有什么区别，没搞懂</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">void</span> connect_phase(uvm_phase phase);</span><br><span class="line">          sb_export_before<span class="variable">.connect</span>(before_fifo<span class="variable">.analysis_export</span>);</span><br><span class="line">          sb_export_after<span class="variable">.connect</span>(after_fifo<span class="variable">.analysis_export</span>);</span><br><span class="line">     <span class="keyword">endfunction</span>: connect_phase</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">task</span> run();</span><br><span class="line">          <span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">               before_fifo<span class="variable">.get</span>(transaction_before);</span><br><span class="line">               after_fifo<span class="variable">.get</span>(transaction_after);</span><br><span class="line">               compare();</span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">     <span class="keyword">endtask</span>: run</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> compare();</span><br><span class="line">          <span class="keyword">if</span>(transaction_before<span class="variable">.out</span> == transaction_after<span class="variable">.out</span>) <span class="keyword">begin</span></span><br><span class="line">               <span class="meta">`uvm_info(&quot;compare&quot;, &#123;&quot;Test: OK!&quot;&#125;, UVM_LOW);</span></span><br><span class="line">          <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">               <span class="meta">`uvm_info(&quot;compare&quot;, &#123;&quot;Test: Fail!&quot;&#125;, UVM_LOW);</span></span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">     <span class="keyword">endfunction</span>: compare</span><br><span class="line"><span class="keyword">endclass</span>: simpleadder_scoreboard</span><br></pre></td></tr></table></figure><h2><span id="九-environment">九、Environment</span></h2><p>env 是一个非常简单的类，它实例化代理和记分板并将它们连接在一起。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> simpleadder_env <span class="keyword">extends</span> uvm_env;</span><br><span class="line">     <span class="meta">`uvm_component_utils(simpleadder_env)</span></span><br><span class="line"> </span><br><span class="line">     simpleadder_agent sa_agent;</span><br><span class="line">     simpleadder_scoreboard sa_sb;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">     <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">          sa_agent    = simpleadder_agent::type_id::create(...</span><br><span class="line">          sa_sb        = simpleadder_scoreboard::type_id::create(...</span><br><span class="line">     <span class="keyword">endfunction</span>: build_phase</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">void</span> connect_phase(uvm_phase phase);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.connect_phase</span>(phase);</span><br><span class="line">          sa_agent<span class="variable">.agent_ap_before</span><span class="variable">.connect</span>(sa_sb<span class="variable">.sb_export_before</span>);</span><br><span class="line">          sa_agent<span class="variable">.agent_ap_after</span><span class="variable">.connect</span>(sa_sb<span class="variable">.sb_export_after</span>);</span><br><span class="line">     <span class="keyword">endfunction</span>: connect_phase</span><br><span class="line"><span class="keyword">endclass</span>: simpleadder_env</span><br></pre></td></tr></table></figure><h2><span id="十-test">十、test</span></h2><p>这个块将派生自 uvm_test 类，它有两个目的：</p><ul><li><p>创建env</p></li><li><p>将sequencer连接到sequence</p></li></ul><p>在最顶层的test模块中连接sequencer和sequence有一个好处，就是我们可以轻松更改传输到 DUT 的数据类型，而不会弄乱agent或sequence的代码。==但这我还不太理解==</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> simpleadder_test <span class="keyword">extends</span> uvm_test;</span><br><span class="line">     <span class="meta">`uvm_component_utils(simpleadder_test)</span></span><br><span class="line"> </span><br><span class="line">     simpleadder_env sa_env;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">     <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">          sa_env = simpleadder_env::type_id::create(...</span><br><span class="line">     <span class="keyword">endfunction</span>: build_phase</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">          simpleadder_sequence sa_seq;</span><br><span class="line"> </span><br><span class="line">          phase<span class="variable">.raise_objection</span>(<span class="variable">.obj</span>(<span class="keyword">this</span>));</span><br><span class="line">               sa_seq = simpleadder_sequence::type_id::create(...</span><br><span class="line">               <span class="keyword">assert</span>(sa_seq<span class="variable">.randomize</span>());</span><br><span class="line">               sa_seq<span class="variable">.start</span>(sa_env<span class="variable">.sa_agent</span><span class="variable">.sa_seqr</span>);</span><br><span class="line">          phase<span class="variable">.drop_objection</span>(<span class="variable">.obj</span>(<span class="keyword">this</span>));</span><br><span class="line">     <span class="keyword">endtask</span>: run_phase</span><br><span class="line"><span class="keyword">endclass</span>: simpleadder_test</span><br></pre></td></tr></table></figure><p>__本文作者__：Yuchen <a href="http://example.com/2021/09/03/UVM/">http://example.com/2021/09/03/UVM/</a> <br>__版权声明__：转载请注明出处！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;认识uvm的结构&quot;&gt;认识UVM的结构&lt;/span&gt;&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文学习资料引用自&lt;a href=&quot;https://colorlesscube.com/uvm-guide-for-beginners/chapter-2-de</summary>
      
    
    
    
    
    <category term="uvm" scheme="http://example.com/tags/uvm/"/>
    
  </entry>
  
  <entry>
    <title>UVM_LAB 1</title>
    <link href="http://example.com/2021/09/03/1/"/>
    <id>http://example.com/2021/09/03/1/</id>
    <published>2021-09-03T14:58:17.000Z</published>
    <updated>2021-09-03T15:18:05.071Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="dut">DUT</span></h3><p><img src="https://img-blog.csdnimg.cn/20190815154630305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoaUFva2Fp,size_16,color_FFFFFF,t_70" alt="img"></p><p>DUT是一个16进出的路由器。</p><h4><span id="输入时序">输入时序</span></h4><p>输入时序中，从frame_n拉低开始，在frame_n拉高结束。</p><p>输入时序中，din分为三个部分：（1）addr 占4个周期，（2）pad 占5个周期，（3）data 长度不定。</p><p>输入时序中，valid_n在(1)输入addr阶段时不关注，在(2)输入pad阶段为高，在(3)输入数据阶段指示数据是否有效。</p><p>其中地址4位，范围0~15，表示数据要从哪个dout转发出去。<br><img src="https://img-blog.csdnimg.cn/20190815160900760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoaUFva2Fp,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;"></p><h4><span id="输出时序">输出时序</span></h4><p>使用frameo_n下降沿表示开始，frameo_n上升沿表示结束。</p><p>然后，转发时序中只包含data阶段，在传输过程中valid_n用来指示数据线是否有效。</p><img src="https://img-blog.csdnimg.cn/20190815161828295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoaUFva2Fp,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;"><h3><span id="lab1">LAB1</span></h3><p>lab1的任务是创建一个基本的tb。</p><p>先看一下顶层模块的代码</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> <span class="keyword">automatic</span> test;</span><br><span class="line"><span class="keyword">import</span> uvm_pkg::*;</span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> &quot;packet.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> &quot;driver.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> &quot;input_agent.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> &quot;router_env.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> &quot;test_collection.sv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  <span class="built_in">$timeformat</span>(-<span class="number">9</span>, <span class="number">1</span>, <span class="string">&quot;ns&quot;</span>, <span class="number">10</span>);</span><br><span class="line">  run_test();</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，引用了上面的几个文件，我们按照UVM的系统图来理解一下</p><p><img src="http://colorlesscube.com/wp-content/uploads/ch3-uvm_tb_typical.png" alt="Typical UVM testbench"></p><h4><span id="packet">Packet</span></h4><p><strong>packet.sv是一个trans，它定义了uvm中传输的数据包的类型</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> packet <span class="keyword">extends</span> uvm_sequence_item;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] sa, da;   <span class="comment">//随机化变量，sa、da分别是源地址和目标地址</span></span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span>[<span class="number">7</span>:<span class="number">0</span>] payload[$];<span class="comment">//payload是数据包队列</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">`uvm_object_utils_begin(packet)</span></span><br><span class="line">    <span class="meta">`uvm_field_int(sa, UVM_ALL_ON | UVM_NOCOMPARE)//关闭域的比较操作</span></span><br><span class="line">    <span class="meta">`uvm_field_int(da, UVM_ALL_ON)</span></span><br><span class="line">    <span class="meta">`uvm_field_queue_int(payload, UVM_ALL_ON)</span></span><br><span class="line">  <span class="meta">`uvm_object_utils_end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constraint</span> valid &#123;</span><br><span class="line">    payload<span class="variable">.size</span> <span class="keyword">inside</span> &#123;[<span class="number">1</span>:<span class="number">10</span>]&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;packet&quot;</span>);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line">  <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"><span class="keyword">endclass</span>: packet</span><br></pre></td></tr></table></figure><p> <em><strong>*为什么要使用 field_automation 机制*</strong></em></p><p>对于这样的一个 transaction，我们经常会用到许多常用的操作，如把所有的字段（成员变量）打印一下， 这个就需要自己写 <strong>print 函数</strong>，这样写起来将会是相当费时间的。而且对于这些常用的操作，如果transaction 的定义换一下，那么这些所有的函数或任务就都需要重新写，这种代价是相当大的。</p><p> <em><strong>field_automation 机制的使用</strong></em></p><p>使用 field macros用在utility mcros中，用来将变量（field）在工厂中注册，以指定参与到类的方法的执行的变量，这叫做field_automation，也就是将这些field像类一样在factory中注册；这些方法如print、copy、compare等就可以直接使用这些在factory中注册过的field.</p><p><strong><code>uvm_field_int(arg,flag)**中的int表示该宏使用的数据类型，如果是字符串，则应该定义为：**</code>uvm_field_string</strong>；括号中表示宏的参数arg和flag（至少两个参数），其他类型的宏可以查看UVM参考手册.</p><p>其中arg为变量名，flag为操作模式，可以取以下的值：</p><img src="https://img-blog.csdnimg.cn/20190527155155759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JsZWF1Y2hhdA==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;"><p>可以通过位操作符指定域的功能。</p><h4><span id="driver">Driver</span></h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> driver <span class="keyword">extends</span> uvm_driver <span class="variable">#(packet)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register component class into UVM factory.</span></span><br><span class="line">  <span class="meta">`uvm_component_utils(driver)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line">  <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">      seq_item_port<span class="variable">.get_next_item</span>(req);</span><br><span class="line">      send(req);</span><br><span class="line">      seq_item_port<span class="variable">.item_done</span>();</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">endtask</span>: run_phase</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">task</span> send(packet pkt);</span><br><span class="line">     <span class="comment">//my code</span></span><br><span class="line">    <span class="meta">`uvm_info(&quot;DRV_RUN&quot;, &#123;&quot;\n&quot;, req.sprint()&#125;, UVM_MEDIUM);</span></span><br><span class="line">  <span class="keyword">endtask</span>: send</span><br><span class="line"></span><br><span class="line"><span class="keyword">endclass</span>: driver</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在trans中，有三个内置的句柄可以使用。第一个是seq_item_port，这是一个内置的TLM端口，他被参数化以将trans发送给driver。接下来的两个句柄是req和rsp(参数类:packet的句柄)。req句柄用于从序列中提取请求对象。rsp句柄用于向序列发回响应。</p><p>sequence+sequencer+driver的体系可以看这个博客</p><p><a href="https://www.cnblogs.com/dreamCll/p/11756761.html">https://www.cnblogs.com/dreamCll/p/11756761.html</a></p><h4><span id="input_agent">input_agent</span></h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">class</span> input_agent <span class="keyword">extends</span> uvm_agent;</span><br><span class="line">  <span class="meta">`uvm_component_utils(input_agent)</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// whenever you are dealing with a parameterized class, it is always a</span></span><br><span class="line">  <span class="comment">// good idea to use the typedef mechanism to hide the parameter for</span></span><br><span class="line">  <span class="comment">// easier handling in the code.  That&#x27;s what you see below.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> uvm_sequencer<span class="variable">#(packet)</span> packet_sequencer;</span><br><span class="line"></span><br><span class="line">  packet_sequencer sqr;</span><br><span class="line">  driver drv;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line">  <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line"></span><br><span class="line">    sqr = packet_sequencer::type_id::create(<span class="string">&quot;sqr&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    drv = driver::type_id::create(<span class="string">&quot;drv&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">endfunction</span>: build_phase</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> connect_phase(uvm_phase phase);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.connect_phase</span>(phase);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line">    </span><br><span class="line">      drv<span class="variable">.seq_item_port</span><span class="variable">.connect</span>(sqr<span class="variable">.seq_item_export</span>);</span><br><span class="line">      <span class="comment">//调用connect（）函数，链接driver和sequencer</span></span><br><span class="line">  <span class="keyword">endfunction</span>: connect_phase</span><br><span class="line"></span><br><span class="line"><span class="keyword">endclass</span>: input_agent</span><br></pre></td></tr></table></figure><p>4-6行是源文件的标注，我老是不记得就把他留下来了，这是使用结构体来简化代码中的句柄。需要注意的是</p><p><code>uvm_sequencer#(packet) packet_sequencer;</code></p><p>#（packet）是指传入uvm_sequencer的类型</p><h4><span id="router_environment">router_environment</span></h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> router_env <span class="keyword">extends</span> uvm_env;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Environment class should instantiate all required agents.</span></span><br><span class="line">  input_agent i_agt;</span><br><span class="line"></span><br><span class="line">  <span class="meta">`uvm_component_utils(router_env)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line">  <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// All components should be constructed using the factory create() method</span></span><br><span class="line">    i_agt = input_agent::type_id::create(<span class="string">&quot;i_agt&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">endfunction</span>: build_phase</span><br><span class="line"></span><br><span class="line"><span class="keyword">endclass</span>: router_env</span><br></pre></td></tr></table></figure><p>在environment中应当实例化所有的agent</p><h4><span id="test_collection">test_collection</span></h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> test_base <span class="keyword">extends</span> uvm_test;</span><br><span class="line">  <span class="meta">`uvm_component_utils(test_base)</span></span><br><span class="line"></span><br><span class="line">  router_env env;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line">  <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line">    env = router_env::type_id::create(<span class="string">&quot;env&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">endfunction</span>: build_phase</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> start_of_simulation_phase(uvm_phase phase);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.start_of_simulation_phase</span>(phase);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line">    <span class="keyword">if</span> (uvm_report_enabled(UVM_MEDIUM, UVM_INFO, <span class="string">&quot;TOPOLOGY&quot;</span>)) <span class="keyword">begin</span></span><br><span class="line">        uvm_root::get()<span class="variable">.print_topology</span>();<span class="comment">//打印UVM树</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> (uvm_report_enabled(UVM_MEDIUM, UVM_INFO, <span class="string">&quot;FACTORY&quot;</span>)) <span class="keyword">begin</span></span><br><span class="line">        uvm_factory::get()<span class="variable">.print</span>();<span class="comment">//打印注册关系</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">endfunction</span>: start_of_simulation_phase</span><br><span class="line"><span class="keyword">endclass</span>: test_base</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中，uvm_report_enabled这个函数的作用如下</p><p><a href="https://imgtu.com/i/hcYH6e"><img src="https://z3.ax1x.com/2021/09/03/hcYH6e.png" alt="hcYH6e.png"></a></p><p>这是用于检查severity/ID是否小于verbosity，如果满足则显示为1。</p><blockquote><p>关于verbosity可以看这个博客</p><p><a href="https://east1203.github.io/2019/07/22/Verification/UVM/UVM%E2%80%94%E2%80%94%E6%8E%A7%E5%88%B6%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF/">https://east1203.github.io/2019/07/22/Verification/UVM/UVM%E2%80%94%E2%80%94%E6%8E%A7%E5%88%B6%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF/</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;span id=&quot;dut&quot;&gt;DUT&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190815154630305.png?x-oss-process=image/watermark,type_ZmFuZ3po</summary>
      
    
    
    
    
    <category term="uvm" scheme="http://example.com/tags/uvm/"/>
    
  </entry>
  
</feed>
