<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-09-03T15:16:43.695Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UVM</title>
    <link href="http://example.com/2021/09/03/UVM/"/>
    <id>http://example.com/2021/09/03/UVM/</id>
    <published>2021-09-03T15:16:04.000Z</published>
    <updated>2021-09-03T15:16:43.695Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="认识uvm的结构">认识UVM的结构</span></h1><blockquote><p>本文学习资料引用自<a href="https://colorlesscube.com/uvm-guide-for-beginners/chapter-2-defining-the-verification-environment/">https://colorlesscube.com/uvm-guide-for-beginners/chapter-2-defining-the-verification-environment/</a></p></blockquote><h2><span id="一-dut介绍">一、DUT介绍</span></h2><p>DUT是一个简单的加法器，时序图和状态机见图。具体作用是两个通道ina和inb，将他们相加再通过out输出，输入的信号采样到en_i,输出的信号采样到en_o。</p><p><img src="https://img-blog.csdnimg.cn/20210829234407908.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFyb2xkIEZleQ==,size_15,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><img src="http://colorlesscube.com/wp-content/uploads/ch2-dut_state_machine.png" alt="DUT State Machine" style="zoom:50%;"><img src="http://colorlesscube.com/wp-content/uploads/ch2-dut_timing_diagram.png" alt="DUT Timing Diagram" style="zoom:50%;"><h2><span id="二-验证环境">二、验证环境</span></h2><p><img src="http://colorlesscube.com/wp-content/uploads/ch3-uvm_tb_typical.png" alt="Typical UVM testbench"></p><h2><span id="三-top-block">三、Top block!</span></h2><p>在正常的开发中，DUT的开发是与TB的开发分开的，因此会有两个部分来连接他们，包括</p><ol><li>TB的顶层模块（Top block ）</li><li>虚拟接口（virtual interface）</li></ol><p>顶层模块例化DUT和TB，而接口则负责连接他们。</p><p>一个典型的接口如下,可以看到接口部分只例化了名称，但没有标明具体的输入输出。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> simpleadder_if;</span><br><span class="line">     <span class="keyword">logic</span>    sig_clock;</span><br><span class="line">     <span class="keyword">logic</span>    sig_ina;</span><br><span class="line">     <span class="keyword">logic</span>    sig_inb;</span><br><span class="line">     <span class="keyword">logic</span>    sig_en_i;</span><br><span class="line">     <span class="keyword">logic</span>    sig_out;</span><br><span class="line">     <span class="keyword">logic</span>    sig_en_o;</span><br><span class="line"><span class="keyword">endinterface</span>: simpleadder_if</span><br></pre></td></tr></table></figure><p>顶层模块的任务包括：</p><ol><li><p>将DUT连接到测试文件</p></li><li><p>生成DUT测试需要的时钟</p></li><li><p>将interface在UVM factory中注册</p></li><li><p>运行测试</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">include</span> &quot;simpleadder_pkg.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> &quot;simpleadder.v&quot;</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> &quot;simpleadder_if.sv&quot;//引用所需要的包文件、头文件以及接口文件</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">module</span> simpleadder_tb_top;</span><br><span class="line">     <span class="keyword">import</span> uvm_pkg::*;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//Interface declaration 例化接口</span></span><br><span class="line">     simpleadder_if vif();</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//Connects the Interface to the DUT 将接口与DUT连接</span></span><br><span class="line">     simpleadder dut(vif<span class="variable">.sig_clock</span>,</span><br><span class="line">                     vif<span class="variable">.sig_en_i</span>,</span><br><span class="line">                     vif<span class="variable">.sig_ina</span>,</span><br><span class="line">                     vif<span class="variable">.sig_inb</span>,</span><br><span class="line">                     vif<span class="variable">.sig_en_o</span>,</span><br><span class="line">                     vif<span class="variable">.sig_out</span>);</span><br><span class="line">     <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">          <span class="comment">//Registers the Interface in the configuration block</span></span><br><span class="line">          <span class="comment">//so that other blocks can use it 注册</span></span><br><span class="line">          uvm_resource_db<span class="variable">#(virtual simpleadder_if)::set(.scope(&quot;ifs&quot;), .name(&quot;simpleadder_if&quot;), .val(vif))</span>;</span><br><span class="line"> </span><br><span class="line">          <span class="comment">//Executes the test</span></span><br><span class="line">          run_test();</span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">     <span class="comment">//Variable initialization</span></span><br><span class="line">     <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">          vif<span class="variable">.sig_clock</span> = <span class="number">1&#x27;b1</span>;</span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">     <span class="comment">//Clock generation</span></span><br><span class="line">     <span class="keyword">always</span></span><br><span class="line">          #<span class="number">5</span> vif<span class="variable">.sig_clock</span> = ~vif<span class="variable">.sig_clock</span>;</span><br><span class="line">     <span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2><span id="四-sequences-and-sequencers">四、Sequences and sequencers</span></h2><p>验证DUT的功能时，需要产生一连串的数据。这就产生了transaction这个类。</p><h3><span id="transaction">transaction</span></h3><p>transaction是一个由<em>uvm_transaction</em> 或者<em>uvm_sequence_item</em>延伸出的类，其中包含了需要传给DUT的数据。</p><p>transaction是验证结构中所使用的最小的数据单位，包括数据类型、变量和方法，优秀的设计可以让transaction多次复用。</p><p>在有了基本的数据包之后，验证环境将需要生成它们的集合并准备好将它们发送给驱动程序。这是序列（sequence）的工作。sequence相当于一个弹夹，其延伸于 <em>uvm_sequence</em>，将trans形成有序集合发送给sequencer，而sequencer的任务是将sequence形成的数据包发送给driver。</p><p><img src="https://colorlesscube.com/wp-content/uploads/ch5-uvm_tb_sequence.png" alt="img"></p><p>一个简单的trans如下</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> simpleadder_transaction <span class="keyword">extends</span> uvm_sequence_item;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span>[<span class="number">1</span>:<span class="number">0</span>] ina;<span class="comment">//随机化输入的a、b数据</span></span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span>[<span class="number">1</span>:<span class="number">0</span>] inb;<span class="comment">//</span></span><br><span class="line">     <span class="keyword">bit</span>[<span class="number">2</span>:<span class="number">0</span>] out;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;&quot;</span>);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.new</span>(name);</span><br><span class="line">     <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">`uvm_object_utils_begin(simpleadder_transaction)//注册</span></span><br><span class="line">    <span class="meta">`uvm_field_int(ina, UVM_ALL_ON)//使用uvm_field宏进行注册</span></span><br><span class="line">     <span class="meta">`uvm_field_int(inb, UVM_ALL_ON)</span></span><br><span class="line">     <span class="meta">`uvm_field_int(out, UVM_ALL_ON)</span></span><br><span class="line">     <span class="meta">`uvm_object_utils_end</span></span><br><span class="line"><span class="keyword">endclass</span>: simpleadder_transaction</span><br></pre></td></tr></table></figure><p>关于uvm_field</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">define</span> uvm_field_int(ARG,FLAG)</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">define</span> uvm_field_real(ARG,FLAG)</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">define</span> uvm_field_enum(T,ARG,FLAG)</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">define</span> uvm_field_object(ARG,FLAG)</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">define</span> uvm_field_event(ARG,FLAG)</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">define</span> uvm_field_string(ARG,FLAG)</span></span><br><span class="line">上述几个宏分别用于要注册的字段是整数、实数、枚举类型、直接或间接派生自uvm_object的类型、事件及字符串类型。这里除了枚举类型外，都是两个参数。对于枚举类型来说，需要有三个参数。假如有枚举类型tb_bool_e，同时有变量tb_flag，那么在使用field automation机制时应该使用如下方式实现：</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;TB_TRUE, TB_FALSE&#125; tb_bool_e;</span><br><span class="line">…</span><br><span class="line">tb_bool_e tb_flag;</span><br><span class="line">…</span><br><span class="line"><span class="meta">`uvm_field_enum(tb_bool_e, tb_flag, UVM_ALL_ON)</span></span><br></pre></td></tr></table></figure><p>而使用trans的好处在于，如果我们需要在测试一个三接口的dut，我们无需重写，只要从原来的trans里拓展出一个新trans就可以，如下</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> simpleadder_transaction_3inputs <span class="keyword">extends</span> simpleadder_transaction;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span>[<span class="number">1</span>:<span class="number">0</span>] inc;<span class="comment">//添加新接口inc</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;&quot;</span>);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.new</span>(name);</span><br><span class="line">     <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"> </span><br><span class="line">     <span class="meta">`uvm_object_utils_begin(simpleadder_transaction_3inputs)</span></span><br><span class="line">    <span class="meta">`uvm_field_int(inc, UVM_ALL_ON)//注册新接口inc</span></span><br><span class="line">     <span class="meta">`uvm_object_utils_end</span></span><br><span class="line"><span class="keyword">endclass</span>: simpleadder_transaction_3inputs</span><br></pre></td></tr></table></figure><h3><span id="sequence">Sequence</span></h3><p>创建了trans之后，就可以写一个由trans组成的sequence</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> simpleadder_sequence <span class="keyword">extends</span> uvm_sequence<span class="variable">#(simpleadder_transaction)</span>;<span class="comment">//创建新类，调用之前设置好的trans</span></span><br><span class="line">     <span class="meta">`uvm_object_utils(simpleadder_sequence)</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;&quot;</span>);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.new</span>(name);</span><br><span class="line">     <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">task</span> body();</span><br><span class="line">          simpleadder_transaction sa_tx;</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">repeat</span>(<span class="number">15</span>) <span class="keyword">begin</span><span class="comment">//产生15个trans</span></span><br><span class="line">             sa_tx = simpleadder_transaction::type_id::create(...<span class="comment">//使用create函数产生空白trans</span></span><br><span class="line"> </span><br><span class="line">               start_item(sa_tx);</span><br><span class="line">                    <span class="keyword">assert</span>(sa_tx<span class="variable">.randomize</span>());</span><br><span class="line">               finish_item(sa_tx);</span><br><span class="line">         <span class="keyword">end</span><span class="comment">//随机化，start()和finish()函数分别是阻塞函数</span></span><br><span class="line">     <span class="keyword">endtask</span>: body</span><br><span class="line"><span class="keyword">endclass</span>: simpleadder_sequence</span><br></pre></td></tr></table></figure><h3><span id="sequencer">Sequencer</span></h3><p>而sequencer则只需要一行很短的代码</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> uvm_sequencer<span class="variable">#(simpleadder_transaction)</span> simpleadder_sequencer;</span><br></pre></td></tr></table></figure><p>这告诉UVM系统，只需要使用默认参数创建一个sequencer。</p><p>至此，我们构建出了DUT、Interface、Sequencer</p><p><img src="http://colorlesscube.com/wp-content/uploads/ch5-uvm_tb_simpleadder_sequencer.png" alt="State of the verification environment after the sequencer"></p><p>但是仍有两个问题没有解决：</p><ol><li>sequence如何连接到sequencer</li><li>sequencer如何连接到driver</li></ol><h2><span id="五-driver">五、Driver</span></h2><p>Driver是一个与Dut交互的元件，可以从上图看到driver从Sequencer中接受trans，在通过interface发送给dut。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> simpleadder_driver <span class="keyword">extends</span> uvm_driver<span class="variable">#(simpleadder_transaction)</span>;</span><br><span class="line">    <span class="comment">//The #(simpleadder_transaction) is a SystemVerilog parameter</span></span><br><span class="line">    <span class="comment">//it represents the data type that it will be retrieved from the sequencer.</span></span><br><span class="line">    </span><br><span class="line">     <span class="meta">`uvm_component_utils(simpleadder_driver)</span></span><br><span class="line"> </span><br><span class="line">     <span class="comment">//Interface declaration</span></span><br><span class="line">     <span class="keyword">protected</span> <span class="keyword">virtual</span> simpleadder_if vif;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">     <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">     <span class="keyword">void</span>&#x27;(uvm_resource_db<span class="variable">#(virtual simpleadder_if)::read_by_name(.scope(&quot;ifs&quot;), .name(&quot;simpleadder_if&quot;), .val(vif)))</span>;<span class="comment">//gets the interface from the factory database</span></span><br><span class="line">     <span class="keyword">endfunction</span>: build_phase</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">          <span class="comment">//Our code here</span></span><br><span class="line">     <span class="keyword">endtask</span>: run_phase</span><br><span class="line"><span class="keyword">endclass</span>: simpleadder_driver</span><br></pre></td></tr></table></figure><p>run_phase()的任务就是根据前面的状态机写代码</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> <span class="keyword">task</span> drive();</span><br><span class="line">    simpleadder_transaction sa_tx;</span><br><span class="line">    <span class="keyword">integer</span> counter = <span class="number">0</span>, state = <span class="number">0</span>;</span><br><span class="line">    vif<span class="variable">.sig_ina</span> = <span class="number">0&#x27;b0</span>;</span><br><span class="line">    vif<span class="variable">.sig_inb</span> = <span class="number">0&#x27;b0</span>;</span><br><span class="line">    vif<span class="variable">.sig_en_i</span> = <span class="number">1&#x27;b0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(counter==<span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">//Gets a transaction from the sequencer and</span></span><br><span class="line">            <span class="comment">//stores it in the variable &#x27;sa_tx&#x27;</span></span><br><span class="line">            seq_item_port<span class="variable">.get_next_item</span>(sa_tx);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">        @(<span class="keyword">posedge</span> vif<span class="variable">.sig_clock</span>)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(counter==<span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">                vif<span class="variable">.sig_en_i</span> = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                state = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span>(counter==<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                vif<span class="variable">.sig_en_i</span> = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span>   </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">case</span>(state)</span><br><span class="line">                <span class="number">1</span>: <span class="keyword">begin</span></span><br><span class="line">                    vif<span class="variable">.sig_ina</span> = sa_tx<span class="variable">.ina</span>[<span class="number">1</span>];</span><br><span class="line">                    vif<span class="variable">.sig_inb</span> = sa_tx<span class="variable">.inb</span>[<span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line">                    sa_tx<span class="variable">.ina</span> = sa_tx<span class="variable">.ina</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                    sa_tx<span class="variable">.inb</span> = sa_tx<span class="variable">.inb</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">                    counter = counter + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(counter==<span class="number">2</span>) state = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">                <span class="number">2</span>: <span class="keyword">begin</span></span><br><span class="line">                    vif<span class="variable">.sig_ina</span> = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    vif<span class="variable">.sig_inb</span> = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    counter = counter + <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">if</span>(counter==<span class="number">6</span>) <span class="keyword">begin</span></span><br><span class="line">                        counter = <span class="number">0</span>;</span><br><span class="line">                        state = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">                        <span class="comment">//Informs the sequencer that the</span></span><br><span class="line">                        <span class="comment">//current operation with</span></span><br><span class="line">                        <span class="comment">//the transaction was finished</span></span><br><span class="line">                        seq_item_port<span class="variable">.item_done</span>();</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span>: drive</span><br></pre></td></tr></table></figure><p>关于virtual这个关键词可以展开说一下，不好排版，放在后面吧</p><p>==关于uvm_resource_db这个机制，可以参考<a href="http://www.dvagent.com/forum.php?mod=viewthread&amp;tid=269%EF%BC%8C%E7%AD%89%E6%9C%89%E7%A9%BA%E4%BA%86%E6%88%91%E5%86%8D%E6%9D%A5%E6%95%B4%E7%90%86==">http://www.dvagent.com/forum.php?mod=viewthread&amp;tid=269，等有空了我再来整理==</a></p><h3><span id="virtual">virtual</span></h3><ol><li><h5><span id="virtual-interface">virtual interface</span></h5><ul><li>在interface定义时，如果不使用关键字 “virtual” 那么==在多次调用该接口时，在其中的一个实例中对接口中某一信号的修改会影响其他实例接口==；如果使用了 “virtual” 关键字，那么每个实例是独立的。</li><li>习惯上在声明interface时均添加 “virtual”关键字。</li></ul></li><li><h5><span id="virtual-taskfunction">virtual task/function</span></h5><ul><li><p>用于OOP思想的继承使用。当定义了virtual时，==在子类中调用某task/function时，会先查找在子类中是否定义了该 task/function，如果子类没有定义，则在父类中查找。==未定义virtual时，只在子类中查找，没有定义就是编译器报错。</p></li><li><p>如果某一class会被继承，则用户定义的task/function（除new()，randomized()，per_randomize()，pose_randomize()外），都应该加上virtual关键字，以备后续扩展。</p></li></ul></li><li><h5><span id="virtual-class">virtual class</span></h5><ul><li><p>虚类一般用来定义类的格式,、类的成员、类的参数等，==虚类不能被实例化==，只能被扩展（重载）后实例化，用于在项目中定义一些标准的类。</p></li><li><p>虚类中的方法通常使用关键字 “ pure virtual “ 纯虚方法。同时OOP规定，只要class中存在一个没有被实现的pure function，就不允许例化这个class。</p></li></ul></li></ol><h3><span id="local-protected-static">local、protected、static</span></h3><ol><li>公有与私有<ul><li>在SV中，所有成员默认都是 public 类型的，除非显示的使用关键字 <strong>local/protected</strong> 来声明。local与protected均可对方法或者属性进行修饰说明。</li><li>local 表示的成员或方法只对该类的对象可见，扩展类以及类外不可见；</li><li>protected 表示的成员或方法对该类==以及扩展类可见==，对类外不可见；</li></ul></li><li>静态与全局</li></ol><h5><span id="静态属性">静态属性</span></h5><p>对于普通的实例类属性，每一个类实例的每一个变量都有自己的copy（单独的内存空间），相互独立。但是有时会要求一个类的所有实例都共享变量的一个版本，也就是说所有实例都共享同一个copy，该变量对所有实例都是可见并相同的。</p><p>这样的类属性就是静态属性（静态变量），使用关键字<strong>static</strong>产生。通过下面的例子可以清楚的看见静态属性的特点。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line">  <span class="keyword">bit</span> [<span class="number">15</span>:<span class="number">0</span>]   addr;</span><br><span class="line">  <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>]   data;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span>   static_ctr = <span class="number">0</span>;<span class="comment">//static</span></span><br><span class="line">       <span class="keyword">int</span>   ctr = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span> (<span class="keyword">bit</span> [<span class="number">15</span>:<span class="number">0</span>] ad, <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] d);</span><br><span class="line">    addr = ad;</span><br><span class="line">    data = d;</span><br><span class="line">    static_ctr++;</span><br><span class="line">    ctr++;</span><br><span class="line">    <span class="built_in">$display</span> (<span class="string">&quot;static_ctr=%0d ctr=%0d addr=0x%0h data=0x%0h&quot;</span>, static_ctr, ctr, addr, data);</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    Packet   p1, p2, p3;</span><br><span class="line">    p1 = <span class="keyword">new</span> (<span class="number">16&#x27;hdead</span>, <span class="number">8&#x27;h12</span>);</span><br><span class="line">    p2 = <span class="keyword">new</span> (<span class="number">16&#x27;hface</span>, <span class="number">8&#x27;hab</span>);</span><br><span class="line">    p3 = <span class="keyword">new</span> (<span class="number">16&#x27;hcafe</span>, <span class="number">8&#x27;hfc</span>);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ncsim&gt; run</span><br><span class="line">static_ctr=<span class="number">1</span> ctr=<span class="number">1</span> addr=<span class="number">0</span>xdead data=<span class="number">0</span>x12<span class="comment">//可以看到ctr只在单次的new中产生</span></span><br><span class="line">static_ctr=<span class="number">2</span> ctr=<span class="number">1</span> addr=<span class="number">0</span>xface data=<span class="number">0</span>xab<span class="comment">//而static_ctr则始终在计数</span></span><br><span class="line">static_ctr=<span class="number">3</span> ctr=<span class="number">1</span> addr=<span class="number">0</span>xcafe data=<span class="number">0</span>xfc</span><br><span class="line">ncsim: *W,RNQUIE: Simulation is complete.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>静态属性还有一个重要的特点是<strong>其类无需实例化，就可直接使用静态属性</strong>。需要利用范围操作符::</p><p>一个静态方法遵守所有的类范围和访问规则，**但是它可以在类的外部被调用，即使没有该类的实例。外部调用的方法同样需要使用范围操作符::**。</p><h5><span id="静态方法">静态方法</span></h5><p>一个静态方法不能访问非静态的属性或方法，但是可以直接访问静态属性，或者调用同一个类中的静态方法，原因很简单因为静态属性和静态方法可以在类没有实例化时被调用，具有全局的静态生命周期，而普通的非静态成员无法做到这点。<br>在一个静态方法内部访问非静态成员或者使用this句柄都是非法的。<br>静态方法不能是虚拟的。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> ctr=<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">function</span> <span class="keyword">new</span> ();</span><br><span class="line">      ctr++;</span><br><span class="line">   <span class="keyword">endfunction</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">function</span> get_pkt_ctr ();</span><br><span class="line">    <span class="built_in">$display</span> (<span class="string">&quot;ctr=%0d&quot;</span>, ctr);</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">  Packet pkt [<span class="number">6</span>];</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">$size</span>(pkt); i++) <span class="keyword">begin</span></span><br><span class="line">      pkt[i] = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    Packet::get_pkt_ctr();   <span class="comment">// Static call using :: operator</span></span><br><span class="line">    pkt[<span class="number">5</span>]<span class="variable">.get_pkt_ctr</span>();   <span class="comment">// Normal call using instance</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ncsim&gt; run</span><br><span class="line">ctr=<span class="number">6</span></span><br><span class="line">ctr=<span class="number">6</span></span><br><span class="line">ncsim: *W,RNQUIE: Simulation is complete.</span><br></pre></td></tr></table></figure><p>可以看到，通过域操作符和使用实例中的函数，得到的结果是相同的，并且pkt[]的6个成员的调用结果都会是一样的（操作对象是只有一个copy的静态属性）。</p><h2><span id="六-monitor">六、Monitor</span></h2><p>监视器是一个无源元件，它不会将任何信号驱动到 DUT 中，其目的是提取信号信息并将其转换为有意义的信息以供其他元件评估。</p><p>监测器应包括：</p><ul><li><p>遵守协议的 DUT 输出</p></li><li><p>用于功能覆盖分析的 DUT 输入</p></li></ul><p>在本例中，我们创建两个monitor，对两个输入进行采样，对预期结果进行预测并将其与 DUT 的结果进行比较：</p><ul><li><p>第一个监视器 monitor_before 将只查找设备的输出并将结果传递给记分板。</p></li><li><p>第二个监视器 monitor_after 将获得两个输入并对预期结果进行预测。记分板也会得到这个预测结果，并对两个值进行比较。</p></li></ul><p>monitor_before</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> simpleadder_monitor_before <span class="keyword">extends</span> uvm_monitor;</span><br><span class="line">     <span class="meta">`uvm_component_utils(simpleadder_monitor_before)</span></span><br><span class="line"> </span><br><span class="line">    uvm_analysis_port<span class="variable">#(simpleadder_transaction)</span> mon_ap_before;<span class="comment">//</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">virtual</span> simpleadder_if vif;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">     <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line"> </span><br><span class="line">          <span class="keyword">void</span>&#x27;(uvm_resource_db<span class="variable">#(virtual simpleadder_if)::read_by_name (.scope(&quot;ifs&quot;), .name(&quot;simpleadder_if&quot;), .val(vif)))</span>;</span><br><span class="line">          mon_ap_before = <span class="keyword">new</span>(<span class="variable">.name</span>(<span class="string">&quot;mon_ap_before&quot;</span>), <span class="variable">.parent</span>(<span class="keyword">this</span>));</span><br><span class="line">     <span class="keyword">endfunction</span>: build_phase</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">          <span class="comment">//Our code here</span></span><br><span class="line">     <span class="keyword">endtask</span>: run_phase</span><br><span class="line"><span class="keyword">endclass</span>: simpleadder_monitor_before</span><br></pre></td></tr></table></figure><p>monitor_after</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> simpleadder_monitor_after <span class="keyword">extends</span> uvm_monitor;</span><br><span class="line">     <span class="meta">`uvm_component_utils(simpleadder_monitor_after)</span></span><br><span class="line"> </span><br><span class="line">     uvm_analysis_port<span class="variable">#(simpleadder_transaction)</span> mon_ap_after;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">virtual</span> simpleadder_if vif;</span><br><span class="line"> </span><br><span class="line">     simpleadder_transaction sa_tx_cg;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">covergroup</span> simpleadder_cg;</span><br><span class="line">          ina_cp:     <span class="keyword">coverpoint</span> sa_tx_cg<span class="variable">.ina</span>;</span><br><span class="line">          inb_cp:     <span class="keyword">coverpoint</span> sa_tx_cg<span class="variable">.inb</span>;</span><br><span class="line">          <span class="keyword">cross</span> ina_cp, inb_cp;</span><br><span class="line">     <span class="keyword">endgroup</span>: simpleadder_cg</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">          simpleadder_cg = <span class="keyword">new</span>;</span><br><span class="line">     <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line"> </span><br><span class="line">          <span class="keyword">void</span>&#x27;(uvm_resource_db<span class="variable">#(virtual simpleadder_if)::read_by_name(.scope(&quot;ifs&quot;), .name(&quot;simpleadder_if&quot;), .val(vif)))</span>;</span><br><span class="line">          mon_ap_after= <span class="keyword">new</span>(<span class="variable">.name</span>(<span class="string">&quot;mon_ap_after&quot;</span>), <span class="variable">.parent</span>(<span class="keyword">this</span>));</span><br><span class="line">     <span class="keyword">endfunction</span>: build_phase</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">          <span class="comment">//Our code here</span></span><br><span class="line">     <span class="keyword">endtask</span>: run_phase</span><br><span class="line"><span class="keyword">endclass</span>: simpleadder_monitor_after</span><br></pre></td></tr></table></figure><h4><span id="tlm-端口">TLM 端口</span></h4><p>在讨论trans时，我们忽略了一个问题，就是其如何在各个元件中间流通，答案是通过端口。</p><p>TLM 代表事务级建模（Transaction Level Modeling），它是一种对数字系统之间的通信进行建模的高级方法。这种方法主要体现在两个方面：端口和出口。</p><p><img src="http://colorlesscube.com/wp-content/uploads/ch7-uvm_port_export.png" alt="Port-export communication"></p><p>如上所示，consumer实现一个函数，该函数使用一个trans作为参数，而producer调用该函数，同时将作为参数的trans传递给consumer。top_class将这两个元件组合在一起。</p><p>一个例子如下图</p><img src="http://colorlesscube.com/wp-content/uploads/ch7-uvm_port_export_sample_code.jpeg" alt="Sample code for ports and exports" style="zoom:80%;"><p>这张图中，top_class使用connect方法将consumer的端口连接到了productor的端口上</p><p><img src="http://colorlesscube.com/wp-content/uploads/ch7-uvm_port_export_sumup.png" alt="Sum up of TLM-1.0 ports"></p><p>而在port和export是一一对应的关系，而在需要一对多的时候，可以使用analysis port。</p><p><img src="http://colorlesscube.com/wp-content/uploads/ch7-uvm_analysis_port_export.png" alt="Analysis port communication"></p><h2><span id="七-agent">七、Agent</span></h2><p>在有了sequencer、driver 、monitor之后，下一步的任务是将它们链接起来，这一步由agent来完成。</p><p>agent中没有run_phase，一个connect_phase取代了它。</p><p>我们将在构建阶段构建monitor、sequencer、driver。我们还需要创建两个分析端口，这些端口将充当监视器的代理，以便通过代理端口连接到外部scoreboard。</p><p><img src="http://colorlesscube.com/wp-content/uploads/ch8-uvm_tb_simpleadder_agent.png" alt="State of the testbench after the agent"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> simpleadder_agent <span class="keyword">extends</span> uvm_agent;</span><br><span class="line">     <span class="meta">`uvm_component_utils(simpleadder_agent)</span></span><br><span class="line"> </span><br><span class="line">     <span class="comment">//Analysis ports to connect the monitors to the scoreboard</span></span><br><span class="line">     uvm_analysis_port<span class="variable">#(simpleadder_transaction)</span> agent_ap_before;</span><br><span class="line">     uvm_analysis_port<span class="variable">#(simpleadder_transaction)</span> agent_ap_after;</span><br><span class="line"> </span><br><span class="line">     simpleadder_sequencer        sa_seqr;</span><br><span class="line">     simpleadder_driver        sa_drvr;</span><br><span class="line">     simpleadder_monitor_before    sa_mon_before;</span><br><span class="line">     simpleadder_monitor_after    sa_mon_after;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">     <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line"> </span><br><span class="line">          agent_ap_before    = <span class="keyword">new</span>(<span class="variable">.name</span>(<span class="string">&quot;agent_ap_before&quot;</span>), <span class="variable">.parent</span>(<span class="keyword">this</span>));</span><br><span class="line">          agent_ap_after    = <span class="keyword">new</span>(<span class="variable">.name</span>(<span class="string">&quot;agent_ap_after&quot;</span>), <span class="variable">.parent</span>(<span class="keyword">this</span>));</span><br><span class="line"> </span><br><span class="line">          sa_seqr        = simpleadder_sequencer::type_id::create(...</span><br><span class="line">          sa_drvr        = simpleadder_driver::type_id::create(...</span><br><span class="line">          sa_mon_before    = simpleadder_monitor_before::type_id::create(...</span><br><span class="line">          sa_mon_after    = simpleadder_monitor_after::type_id::create(...</span><br><span class="line">     <span class="keyword">endfunction</span>: build_phase</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">void</span> connect_phase(uvm_phase phase);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.connect_phase</span>(phase);</span><br><span class="line">          sa_drvr<span class="variable">.seq_item_port</span><span class="variable">.connect</span>(sa_seqr<span class="variable">.seq_item_export</span>);</span><br><span class="line">          sa_mon_before<span class="variable">.mon_ap_before</span><span class="variable">.connect</span>(agent_ap_before);</span><br><span class="line">          sa_mon_after<span class="variable">.mon_ap_after</span><span class="variable">.connect</span>(agent_ap_after);</span><br><span class="line">     <span class="keyword">endfunction</span>: connect_phase</span><br><span class="line"><span class="keyword">endclass</span>: simpleadder_agent</span><br></pre></td></tr></table></figure><p>关于uvm_resource_db这个指令，有一个简单的例子，具体的应用应该还要再查书。</p><blockquote><p>以下将创建一个新资源，填充它并将其插入到资源池中。</p><p>uvm_resource_db#（int）::set(“roman”,”top.aa..*”,2011,this);</p><p>我们创建了一个名为“roman”的新资源，在“top.aa..*”标识的范围内可见，值为2011。</p><p>检索此资源的组件将从数据库中读取值。</p><p>if(!uvm_resource_db#（int）::read_by_name(“roman”,get_full_name(),value,this))</p><p>`uvm_error(“WRONG”,”在此范围内未找到资源”);</p><p>read_by_name() 返回一个指示查找是否成功的位。</p><p>uvm_resource_db#（T）类是底层数据库访问类和方法之上的一个便利层。它没有被实例化。但包含一组操作资源和资源池的静态函数。</p><p><a href="https://forums.accellera.org/topic/305-uvm_resource_db-class-usage/">https://forums.accellera.org/topic/305-uvm_resource_db-class-usage/</a></p></blockquote><h2><span id="八-scoreboard">八、Scoreboard</span></h2><p>scoreboard是关键一环，用于检测dut的功能是否正确，其编写是最重要的。</p><p>在agent中，我们创建了两个监视器，因此，我们必须在记分板中创建两个analysis port，用于从两个监视器检索交易。之后，将在运行阶段执行一个方法 compare() 并比较两个事务。如果它们匹配，则意味着测试平台和 DUT 在功能上都一致，它将返回“OK”消息。</p><p>但是我们有一个问题：我们有来自两个监视器的两个事务流，我们需要确保它们是同步的。这可以通过编写适当的 write() 函数来手动完成，但有一种更简单、更清晰的方法：使用 UVM FIFO。==这个fifo要再去查一下==</p><p><img src="http://colorlesscube.com/wp-content/uploads/ch9-uvm_tb_fifo.png" alt="Usage of FIFO in the scoreboard"></p><p>FIFO 的实例化类似于端口/导出，使用 uvm_tlm_analysis_fifo #(generic_transaction) generic_fifo 并且它们已经实现了从监视器调用的相应 write() 函数。要访问它们的数据，我们只需从每个 FIFO 执行 get() 方法。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> simpleadder_scoreboard <span class="keyword">extends</span> uvm_scoreboard;</span><br><span class="line">     <span class="meta">`uvm_component_utils(simpleadder_scoreboard)</span></span><br><span class="line"> </span><br><span class="line">     uvm_analysis_export <span class="variable">#(simpleadder_transaction)</span> sb_export_before;</span><br><span class="line">     uvm_analysis_export <span class="variable">#(simpleadder_transaction)</span> sb_export_after;</span><br><span class="line"> </span><br><span class="line">     uvm_tlm_analysis_fifo <span class="variable">#(simpleadder_transaction)</span> before_fifo;</span><br><span class="line">     uvm_tlm_analysis_fifo <span class="variable">#(simpleadder_transaction)</span> after_fifo;</span><br><span class="line"> </span><br><span class="line">     simpleadder_transaction transaction_before;</span><br><span class="line">     simpleadder_transaction transaction_after;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">          transaction_before    = <span class="keyword">new</span>(<span class="string">&quot;transaction_before&quot;</span>);</span><br><span class="line">          transaction_after    = <span class="keyword">new</span>(<span class="string">&quot;transaction_after&quot;</span>);</span><br><span class="line">     <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">          sb_export_before    = <span class="keyword">new</span>(<span class="string">&quot;sb_export_before&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">          sb_export_after        = <span class="keyword">new</span>(<span class="string">&quot;sb_export_after&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"> </span><br><span class="line">          before_fifo        = <span class="keyword">new</span>(<span class="string">&quot;before_fifo&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">          after_fifo        = <span class="keyword">new</span>(<span class="string">&quot;after_fifo&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">     <span class="keyword">endfunction</span>: build_phase<span class="comment">//build_phase和注册到底有什么区别，没搞懂</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">void</span> connect_phase(uvm_phase phase);</span><br><span class="line">          sb_export_before<span class="variable">.connect</span>(before_fifo<span class="variable">.analysis_export</span>);</span><br><span class="line">          sb_export_after<span class="variable">.connect</span>(after_fifo<span class="variable">.analysis_export</span>);</span><br><span class="line">     <span class="keyword">endfunction</span>: connect_phase</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">task</span> run();</span><br><span class="line">          <span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">               before_fifo<span class="variable">.get</span>(transaction_before);</span><br><span class="line">               after_fifo<span class="variable">.get</span>(transaction_after);</span><br><span class="line">               compare();</span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">     <span class="keyword">endtask</span>: run</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> compare();</span><br><span class="line">          <span class="keyword">if</span>(transaction_before<span class="variable">.out</span> == transaction_after<span class="variable">.out</span>) <span class="keyword">begin</span></span><br><span class="line">               <span class="meta">`uvm_info(&quot;compare&quot;, &#123;&quot;Test: OK!&quot;&#125;, UVM_LOW);</span></span><br><span class="line">          <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">               <span class="meta">`uvm_info(&quot;compare&quot;, &#123;&quot;Test: Fail!&quot;&#125;, UVM_LOW);</span></span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">     <span class="keyword">endfunction</span>: compare</span><br><span class="line"><span class="keyword">endclass</span>: simpleadder_scoreboard</span><br></pre></td></tr></table></figure><h2><span id="九-environment">九、Environment</span></h2><p>env 是一个非常简单的类，它实例化代理和记分板并将它们连接在一起。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> simpleadder_env <span class="keyword">extends</span> uvm_env;</span><br><span class="line">     <span class="meta">`uvm_component_utils(simpleadder_env)</span></span><br><span class="line"> </span><br><span class="line">     simpleadder_agent sa_agent;</span><br><span class="line">     simpleadder_scoreboard sa_sb;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">     <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">          sa_agent    = simpleadder_agent::type_id::create(...</span><br><span class="line">          sa_sb        = simpleadder_scoreboard::type_id::create(...</span><br><span class="line">     <span class="keyword">endfunction</span>: build_phase</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">void</span> connect_phase(uvm_phase phase);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.connect_phase</span>(phase);</span><br><span class="line">          sa_agent<span class="variable">.agent_ap_before</span><span class="variable">.connect</span>(sa_sb<span class="variable">.sb_export_before</span>);</span><br><span class="line">          sa_agent<span class="variable">.agent_ap_after</span><span class="variable">.connect</span>(sa_sb<span class="variable">.sb_export_after</span>);</span><br><span class="line">     <span class="keyword">endfunction</span>: connect_phase</span><br><span class="line"><span class="keyword">endclass</span>: simpleadder_env</span><br></pre></td></tr></table></figure><h2><span id="十-test">十、test</span></h2><p>这个块将派生自 uvm_test 类，它有两个目的：</p><ul><li><p>创建env</p></li><li><p>将sequencer连接到sequence</p></li></ul><p>在最顶层的test模块中连接sequencer和sequence有一个好处，就是我们可以轻松更改传输到 DUT 的数据类型，而不会弄乱agent或sequence的代码。==但这我还不太理解==</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> simpleadder_test <span class="keyword">extends</span> uvm_test;</span><br><span class="line">     <span class="meta">`uvm_component_utils(simpleadder_test)</span></span><br><span class="line"> </span><br><span class="line">     simpleadder_env sa_env;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">     <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">          <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">          sa_env = simpleadder_env::type_id::create(...</span><br><span class="line">     <span class="keyword">endfunction</span>: build_phase</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">          simpleadder_sequence sa_seq;</span><br><span class="line"> </span><br><span class="line">          phase<span class="variable">.raise_objection</span>(<span class="variable">.obj</span>(<span class="keyword">this</span>));</span><br><span class="line">               sa_seq = simpleadder_sequence::type_id::create(...</span><br><span class="line">               <span class="keyword">assert</span>(sa_seq<span class="variable">.randomize</span>());</span><br><span class="line">               sa_seq<span class="variable">.start</span>(sa_env<span class="variable">.sa_agent</span><span class="variable">.sa_seqr</span>);</span><br><span class="line">          phase<span class="variable">.drop_objection</span>(<span class="variable">.obj</span>(<span class="keyword">this</span>));</span><br><span class="line">     <span class="keyword">endtask</span>: run_phase</span><br><span class="line"><span class="keyword">endclass</span>: simpleadder_test</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;认识uvm的结构&quot;&gt;认识UVM的结构&lt;/span&gt;&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文学习资料引用自&lt;a href=&quot;https://colorlesscube.com/uvm-guide-for-beginners/chapter-2-de</summary>
      
    
    
    
    
    <category term="uvm" scheme="http://example.com/tags/uvm/"/>
    
  </entry>
  
  <entry>
    <title>UVM_LAB 1</title>
    <link href="http://example.com/2021/09/03/1/"/>
    <id>http://example.com/2021/09/03/1/</id>
    <published>2021-09-03T14:58:17.000Z</published>
    <updated>2021-09-03T15:18:05.071Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="dut">DUT</span></h3><p><img src="https://img-blog.csdnimg.cn/20190815154630305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoaUFva2Fp,size_16,color_FFFFFF,t_70" alt="img"></p><p>DUT是一个16进出的路由器。</p><h4><span id="输入时序">输入时序</span></h4><p>输入时序中，从frame_n拉低开始，在frame_n拉高结束。</p><p>输入时序中，din分为三个部分：（1）addr 占4个周期，（2）pad 占5个周期，（3）data 长度不定。</p><p>输入时序中，valid_n在(1)输入addr阶段时不关注，在(2)输入pad阶段为高，在(3)输入数据阶段指示数据是否有效。</p><p>其中地址4位，范围0~15，表示数据要从哪个dout转发出去。<br><img src="https://img-blog.csdnimg.cn/20190815160900760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoaUFva2Fp,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;"></p><h4><span id="输出时序">输出时序</span></h4><p>使用frameo_n下降沿表示开始，frameo_n上升沿表示结束。</p><p>然后，转发时序中只包含data阶段，在传输过程中valid_n用来指示数据线是否有效。</p><img src="https://img-blog.csdnimg.cn/20190815161828295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoaUFva2Fp,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;"><h3><span id="lab1">LAB1</span></h3><p>lab1的任务是创建一个基本的tb。</p><p>先看一下顶层模块的代码</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> <span class="keyword">automatic</span> test;</span><br><span class="line"><span class="keyword">import</span> uvm_pkg::*;</span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> &quot;packet.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> &quot;driver.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> &quot;input_agent.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> &quot;router_env.sv&quot;</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">include</span> &quot;test_collection.sv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  <span class="built_in">$timeformat</span>(-<span class="number">9</span>, <span class="number">1</span>, <span class="string">&quot;ns&quot;</span>, <span class="number">10</span>);</span><br><span class="line">  run_test();</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，引用了上面的几个文件，我们按照UVM的系统图来理解一下</p><p><img src="http://colorlesscube.com/wp-content/uploads/ch3-uvm_tb_typical.png" alt="Typical UVM testbench"></p><h4><span id="packet">Packet</span></h4><p><strong>packet.sv是一个trans，它定义了uvm中传输的数据包的类型</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> packet <span class="keyword">extends</span> uvm_sequence_item;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] sa, da;   <span class="comment">//随机化变量，sa、da分别是源地址和目标地址</span></span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span>[<span class="number">7</span>:<span class="number">0</span>] payload[$];<span class="comment">//payload是数据包队列</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">`uvm_object_utils_begin(packet)</span></span><br><span class="line">    <span class="meta">`uvm_field_int(sa, UVM_ALL_ON | UVM_NOCOMPARE)//关闭域的比较操作</span></span><br><span class="line">    <span class="meta">`uvm_field_int(da, UVM_ALL_ON)</span></span><br><span class="line">    <span class="meta">`uvm_field_queue_int(payload, UVM_ALL_ON)</span></span><br><span class="line">  <span class="meta">`uvm_object_utils_end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constraint</span> valid &#123;</span><br><span class="line">    payload<span class="variable">.size</span> <span class="keyword">inside</span> &#123;[<span class="number">1</span>:<span class="number">10</span>]&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name = <span class="string">&quot;packet&quot;</span>);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line">  <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"><span class="keyword">endclass</span>: packet</span><br></pre></td></tr></table></figure><p> <em><strong>*为什么要使用 field_automation 机制*</strong></em></p><p>对于这样的一个 transaction，我们经常会用到许多常用的操作，如把所有的字段（成员变量）打印一下， 这个就需要自己写 <strong>print 函数</strong>，这样写起来将会是相当费时间的。而且对于这些常用的操作，如果transaction 的定义换一下，那么这些所有的函数或任务就都需要重新写，这种代价是相当大的。</p><p> <em><strong>field_automation 机制的使用</strong></em></p><p>使用 field macros用在utility mcros中，用来将变量（field）在工厂中注册，以指定参与到类的方法的执行的变量，这叫做field_automation，也就是将这些field像类一样在factory中注册；这些方法如print、copy、compare等就可以直接使用这些在factory中注册过的field.</p><p><strong><code>uvm_field_int(arg,flag)**中的int表示该宏使用的数据类型，如果是字符串，则应该定义为：**</code>uvm_field_string</strong>；括号中表示宏的参数arg和flag（至少两个参数），其他类型的宏可以查看UVM参考手册.</p><p>其中arg为变量名，flag为操作模式，可以取以下的值：</p><img src="https://img-blog.csdnimg.cn/20190527155155759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JsZWF1Y2hhdA==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;"><p>可以通过位操作符指定域的功能。</p><h4><span id="driver">Driver</span></h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> driver <span class="keyword">extends</span> uvm_driver <span class="variable">#(packet)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register component class into UVM factory.</span></span><br><span class="line">  <span class="meta">`uvm_component_utils(driver)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line">  <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">task</span> run_phase(uvm_phase phase);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">      seq_item_port<span class="variable">.get_next_item</span>(req);</span><br><span class="line">      send(req);</span><br><span class="line">      seq_item_port<span class="variable">.item_done</span>();</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">endtask</span>: run_phase</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">task</span> send(packet pkt);</span><br><span class="line">     <span class="comment">//my code</span></span><br><span class="line">    <span class="meta">`uvm_info(&quot;DRV_RUN&quot;, &#123;&quot;\n&quot;, req.sprint()&#125;, UVM_MEDIUM);</span></span><br><span class="line">  <span class="keyword">endtask</span>: send</span><br><span class="line"></span><br><span class="line"><span class="keyword">endclass</span>: driver</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在trans中，有三个内置的句柄可以使用。第一个是seq_item_port，这是一个内置的TLM端口，他被参数化以将trans发送给driver。接下来的两个句柄是req和rsp(参数类:packet的句柄)。req句柄用于从序列中提取请求对象。rsp句柄用于向序列发回响应。</p><p>sequence+sequencer+driver的体系可以看这个博客</p><p><a href="https://www.cnblogs.com/dreamCll/p/11756761.html">https://www.cnblogs.com/dreamCll/p/11756761.html</a></p><h4><span id="input_agent">input_agent</span></h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">class</span> input_agent <span class="keyword">extends</span> uvm_agent;</span><br><span class="line">  <span class="meta">`uvm_component_utils(input_agent)</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// whenever you are dealing with a parameterized class, it is always a</span></span><br><span class="line">  <span class="comment">// good idea to use the typedef mechanism to hide the parameter for</span></span><br><span class="line">  <span class="comment">// easier handling in the code.  That&#x27;s what you see below.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> uvm_sequencer<span class="variable">#(packet)</span> packet_sequencer;</span><br><span class="line"></span><br><span class="line">  packet_sequencer sqr;</span><br><span class="line">  driver drv;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line">  <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line"></span><br><span class="line">    sqr = packet_sequencer::type_id::create(<span class="string">&quot;sqr&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    drv = driver::type_id::create(<span class="string">&quot;drv&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">endfunction</span>: build_phase</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> connect_phase(uvm_phase phase);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.connect_phase</span>(phase);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line">    </span><br><span class="line">      drv<span class="variable">.seq_item_port</span><span class="variable">.connect</span>(sqr<span class="variable">.seq_item_export</span>);</span><br><span class="line">      <span class="comment">//调用connect（）函数，链接driver和sequencer</span></span><br><span class="line">  <span class="keyword">endfunction</span>: connect_phase</span><br><span class="line"></span><br><span class="line"><span class="keyword">endclass</span>: input_agent</span><br></pre></td></tr></table></figure><p>4-6行是源文件的标注，我老是不记得就把他留下来了，这是使用结构体来简化代码中的句柄。需要注意的是</p><p><code>uvm_sequencer#(packet) packet_sequencer;</code></p><p>#（packet）是指传入uvm_sequencer的类型</p><h4><span id="router_environment">router_environment</span></h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> router_env <span class="keyword">extends</span> uvm_env;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Environment class should instantiate all required agents.</span></span><br><span class="line">  input_agent i_agt;</span><br><span class="line"></span><br><span class="line">  <span class="meta">`uvm_component_utils(router_env)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line">  <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// All components should be constructed using the factory create() method</span></span><br><span class="line">    i_agt = input_agent::type_id::create(<span class="string">&quot;i_agt&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">endfunction</span>: build_phase</span><br><span class="line"></span><br><span class="line"><span class="keyword">endclass</span>: router_env</span><br></pre></td></tr></table></figure><p>在environment中应当实例化所有的agent</p><h4><span id="test_collection">test_collection</span></h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> test_base <span class="keyword">extends</span> uvm_test;</span><br><span class="line">  <span class="meta">`uvm_component_utils(test_base)</span></span><br><span class="line"></span><br><span class="line">  router_env env;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name, uvm_component parent);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(name, parent);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line">  <span class="keyword">endfunction</span>: <span class="keyword">new</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> build_phase(uvm_phase phase);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.build_phase</span>(phase);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line">    env = router_env::type_id::create(<span class="string">&quot;env&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">endfunction</span>: build_phase</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> start_of_simulation_phase(uvm_phase phase);</span><br><span class="line">    <span class="keyword">super</span><span class="variable">.start_of_simulation_phase</span>(phase);</span><br><span class="line">    <span class="meta">`uvm_info(&quot;TRACE&quot;, $sformatf(&quot;%m&quot;), UVM_HIGH);</span></span><br><span class="line">    <span class="keyword">if</span> (uvm_report_enabled(UVM_MEDIUM, UVM_INFO, <span class="string">&quot;TOPOLOGY&quot;</span>)) <span class="keyword">begin</span></span><br><span class="line">        uvm_root::get()<span class="variable">.print_topology</span>();<span class="comment">//打印UVM树</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> (uvm_report_enabled(UVM_MEDIUM, UVM_INFO, <span class="string">&quot;FACTORY&quot;</span>)) <span class="keyword">begin</span></span><br><span class="line">        uvm_factory::get()<span class="variable">.print</span>();<span class="comment">//打印注册关系</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">endfunction</span>: start_of_simulation_phase</span><br><span class="line"><span class="keyword">endclass</span>: test_base</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中，uvm_report_enabled这个函数的作用如下</p><p><a href="https://imgtu.com/i/hcYH6e"><img src="https://z3.ax1x.com/2021/09/03/hcYH6e.png" alt="hcYH6e.png"></a></p><p>这是用于检查severity/ID是否小于verbosity，如果满足则显示为1。</p><blockquote><p>关于verbosity可以看这个博客</p><p><a href="https://east1203.github.io/2019/07/22/Verification/UVM/UVM%E2%80%94%E2%80%94%E6%8E%A7%E5%88%B6%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF/">https://east1203.github.io/2019/07/22/Verification/UVM/UVM%E2%80%94%E2%80%94%E6%8E%A7%E5%88%B6%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF/</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;span id=&quot;dut&quot;&gt;DUT&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190815154630305.png?x-oss-process=image/watermark,type_ZmFuZ3po</summary>
      
    
    
    
    
    <category term="uvm" scheme="http://example.com/tags/uvm/"/>
    
  </entry>
  
</feed>
